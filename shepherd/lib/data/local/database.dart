// lib/data/local/database.dart

import 'dart:io';
import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;

// Import table definitions
import 'tables/users_table.dart';
import 'tables/user_settings_table.dart';
import 'tables/sync_queue_table.dart';
import 'tables/tasks_table.dart';

// Import DAOs
import 'daos/tasks_dao.dart';

// This will be generated by build_runner
part 'database.g.dart';

/// Main database class for Shepherd app - offline-first architecture
///
/// This database provides local persistence for all app data using SQLite via Drift.
/// Key features:
/// - Offline-first: All operations execute locally first, sync to Supabase later
/// - Sync metadata: Every table includes fields for tracking sync state
/// - Version management: Database migrations handled automatically
/// - Type-safe: Drift generates type-safe queries and models
///
/// Architecture:
/// 1. User performs action (create task, log contact, etc.)
/// 2. Data written to local SQLite immediately
/// 3. Operation added to sync_queue for background sync
/// 4. Sync engine pushes changes to Supabase when online
/// 5. Conflicts resolved automatically using version numbers
///
/// Reference: shepherd_technical_specification.md Section 9 - Offline Functionality
@DriftDatabase(
  tables: [
    Users,
    UserSettings,
    SyncQueue,
    Tasks,
  ],
  daos: [
    TasksDao,
  ],
)
class AppDatabase extends _$AppDatabase {
  /// Private constructor for singleton pattern
  AppDatabase._internal() : super(_openConnection());

  /// Singleton instance
  static final AppDatabase _instance = AppDatabase._internal();

  /// Factory constructor returns singleton instance
  factory AppDatabase() => _instance;

  /// Access to TasksDao for task-related operations
  @override
  TasksDao get tasksDao => TasksDao(this);

  /// Schema version - increment when making schema changes
  ///
  /// Version History:
  /// - 1: Initial schema (users, user_settings, sync_queue)
  /// - 2: Added tasks table for task management
  @override
  int get schemaVersion => 2;

  /// Migration strategy for schema changes
  ///
  /// Called automatically when schemaVersion is incremented.
  /// Define migration logic for each version upgrade.
  ///
  /// Example for future migrations:
  /// ```dart
  /// @override
  /// MigrationStrategy get migration {
  ///   return MigrationStrategy(
  ///     onCreate: (Migrator m) async {
  ///       await m.createAll();
  ///     },
  ///     onUpgrade: (Migrator m, int from, int to) async {
  ///       if (from == 1) {
  ///         // Add new table in version 2
  ///         await m.createTable(tasks);
  ///       }
  ///       if (from <= 2) {
  ///         // Add column in version 3
  ///         await m.addColumn(users, users.profileImageUrl);
  ///       }
  ///     },
  ///   );
  /// }
  /// ```
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        // Create all tables on fresh install
        await m.createAll();
      },
      onUpgrade: (Migrator m, int from, int to) async {
        // Migration logic for schema changes
        if (from == 1) {
          // Add tasks table in version 2
          await m.createTable(tasks);
        }
      },
      // Optional: Enable foreign key constraints
      beforeOpen: (details) async {
        await customStatement('PRAGMA foreign_keys = ON');
      },
    );
  }

  // ============================================================================
  // CONVENIENCE METHODS - Add commonly used queries here
  // ============================================================================

  /// Get user by ID
  Future<User?> getUserById(String userId) async {
    return (select(users)..where((u) => u.id.equals(userId))).getSingleOrNull();
  }

  /// Get user by email
  Future<User?> getUserByEmail(String email) async {
    return (select(users)..where((u) => u.email.equals(email))).getSingleOrNull();
  }

  /// Get user settings for a specific user
  Future<UserSetting?> getUserSettings(String userId) async {
    return (select(userSettings)..where((s) => s.userId.equals(userId))).getSingleOrNull();
  }

  /// Get all pending sync queue entries (ordered by creation time)
  Future<List<SyncQueueEntry>> getPendingSyncQueue() async {
    return (select(syncQueue)..orderBy([(e) => OrderingTerm.asc(e.createdAt)])).get();
  }

  /// Get sync queue entries for a specific table
  Future<List<SyncQueueEntry>> getSyncQueueForTable(String table) async {
    return (select(syncQueue)
          ..where((e) => e.affectedTable.equals(table))
          ..orderBy([(e) => OrderingTerm.asc(e.createdAt)]))
        .get();
  }

  /// Remove sync queue entry after successful sync
  Future<int> removeSyncQueueEntry(int entryId) async {
    return (delete(syncQueue)..where((e) => e.id.equals(entryId))).go();
  }

  /// Increment retry count and update error message for failed sync
  Future<void> updateSyncQueueFailure(int entryId, String errorMessage) async {
    final entry = await (select(syncQueue)..where((e) => e.id.equals(entryId))).getSingleOrNull();
    if (entry != null) {
      await (update(syncQueue)..where((e) => e.id.equals(entryId))).write(
        SyncQueueCompanion(
          retryCount: Value(entry.retryCount + 1),
          lastError: Value(errorMessage),
        ),
      );
    }
  }

  /// Get all records with pending sync status (across all tables)
  ///
  /// This is useful for diagnostics and showing sync status to users.
  /// Returns count of unsynced records by table.
  Future<Map<String, int>> getPendingSyncCounts() async {
    final counts = <String, int>{};

    // Count pending users
    final pendingUsers = await (select(users)
          ..where((u) => u.syncStatus.equals('pending')))
        .get();
    if (pendingUsers.isNotEmpty) {
      counts['users'] = pendingUsers.length;
    }

    // Count pending user settings
    final pendingSettings = await (select(userSettings)
          ..where((s) => s.syncStatus.equals('pending')))
        .get();
    if (pendingSettings.isNotEmpty) {
      counts['user_settings'] = pendingSettings.length;
    }

    // Count pending tasks (using DAO)
    final pendingTasks = await tasksDao.getPendingTasks();
    if (pendingTasks.isNotEmpty) {
      counts['tasks'] = pendingTasks.length;
    }

    return counts;
  }

  /// Mark a record as pending sync
  ///
  /// Call this after any local modification to trigger sync.
  /// Updates sync_status to 'pending' and sets local_updated_at timestamp.
  Future<void> markUserAsPending(String userId) async {
    await (update(users)..where((u) => u.id.equals(userId))).write(
      UsersCompanion(
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
        updatedAt: Value(DateTime.now().millisecondsSinceEpoch),
      ),
    );
  }

  /// Mark user settings as pending sync
  Future<void> markUserSettingsAsPending(String settingsId) async {
    await (update(userSettings)..where((s) => s.id.equals(settingsId))).write(
      UserSettingsCompanion(
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
        updatedAt: Value(DateTime.now().millisecondsSinceEpoch),
      ),
    );
  }

  /// Clear all data (for logout/account deletion)
  ///
  /// WARNING: This deletes ALL local data. Use with caution.
  /// Typically called during logout or account deletion.
  Future<void> clearAllData() async {
    await transaction(() async {
      await delete(syncQueue).go();
      await delete(userSettings).go();
      await delete(users).go();
      // Tasks will be deleted via CASCADE from users foreign key
    });
  }
}

/// Creates and configures the database connection
///
/// Platform-specific database file location:
/// - iOS: Application Documents Directory
/// - Android: Application Documents Directory
/// - Desktop: Application Documents Directory
///
/// File name: shepherd.sqlite
LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    // Get platform-specific documents directory
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'shepherd.sqlite'));

    // Log database location for debugging
    print('Database location: ${file.path}');

    // Create NativeDatabase with platform-specific file
    return NativeDatabase(file);
  });
}
