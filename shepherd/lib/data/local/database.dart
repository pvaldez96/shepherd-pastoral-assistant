// lib/data/local/database.dart

import 'package:drift/drift.dart';
import 'package:uuid/uuid.dart';

// Conditional imports for platform-specific database connections
// - Native (mobile/desktop): Uses SQLite via dart:ffi
// - Web: Uses IndexedDB
import 'database_connection_stub.dart'
    if (dart.library.io) 'database_connection_native.dart'
    if (dart.library.html) 'database_connection_web.dart';

// Import table definitions
import 'tables/users_table.dart';
import 'tables/user_settings_table.dart';
import 'tables/sync_queue_table.dart';
import 'tables/tasks_table.dart';
import 'tables/calendar_events_table.dart';
import 'tables/households_table.dart';
import 'tables/people_table.dart';
import 'tables/people_milestones_table.dart';
import 'tables/contact_log_table.dart';

// Import DAOs
import 'daos/tasks_dao.dart';
import 'daos/calendar_events_dao.dart';
import 'daos/households_dao.dart';
import 'daos/people_dao.dart';
import 'daos/contact_log_dao.dart';
import 'daos/people_milestones_dao.dart';

// This will be generated by build_runner
part 'database.g.dart';

/// Main database class for Shepherd app - offline-first architecture
///
/// This database provides local persistence for all app data using SQLite via Drift.
/// Key features:
/// - Offline-first: All operations execute locally first, sync to Supabase later
/// - Sync metadata: Every table includes fields for tracking sync state
/// - Version management: Database migrations handled automatically
/// - Type-safe: Drift generates type-safe queries and models
///
/// Architecture:
/// 1. User performs action (create task, log contact, etc.)
/// 2. Data written to local SQLite immediately
/// 3. Operation added to sync_queue for background sync
/// 4. Sync engine pushes changes to Supabase when online
/// 5. Conflicts resolved automatically using version numbers
///
/// Reference: shepherd_technical_specification.md Section 9 - Offline Functionality
@DriftDatabase(
  tables: [
    Users,
    UserSettings,
    SyncQueue,
    Tasks,
    CalendarEvents,
    Households,
    People,
    PeopleMilestones,
    ContactLogTable,
  ],
  daos: [
    TasksDao,
    CalendarEventsDao,
    HouseholdsDao,
    PeopleDao,
    ContactLogDao,
    PeopleMilestonesDao,
  ],
)
class AppDatabase extends _$AppDatabase {
  /// Private constructor for singleton pattern
  AppDatabase._internal() : super(openConnection());

  /// Singleton instance
  static final AppDatabase _instance = AppDatabase._internal();

  /// Initialization future to ensure migrations run exactly once
  static Future<void>? _initFuture;

  /// Factory constructor returns singleton instance
  factory AppDatabase() => _instance;

  /// Initialize database and ensure migrations are run
  ///
  /// CRITICAL FIX FOR WEB PLATFORMS:
  /// On Flutter web with IndexedDB, Drift migrations (onCreate/onUpgrade)
  /// are triggered lazily on the FIRST database query/operation, not on
  /// connection creation. This means if you create a database instance
  /// but never query it, tables are never created.
  ///
  /// This method forces Drift to run the migration by performing a
  /// simple query. Call this once at app startup before any other
  /// database operations.
  ///
  /// Usage:
  /// ```dart
  /// final db = AppDatabase();
  /// await db.ensureInitialized(); // Must call this first!
  /// // Now database is ready - tables created, migrations run
  /// ```
  ///
  /// Reference: https://drift.simonbinder.eu/web/
  Future<void> ensureInitialized() async {
    // Return cached future if already initialized
    _initFuture ??= _runInitialization();
    return _initFuture!;
  }

  /// Internal initialization that triggers migrations
  Future<void> _runInitialization() async {
    try {
      print('ðŸ”„ [Database] Initializing database and running migrations...');

      // Perform a simple query to trigger migration strategy
      // On first run, this will call onCreate to create all tables
      // Using limit(0) makes it fast - we just need to trigger schema validation
      //
      // NOTE: We use a regular Drift query instead of raw SQL (customSelect)
      // because IndexedDB backend doesn't support raw SQL commands
      await (select(users)..limit(0)).get();

      print('âœ… [Database] Database initialized successfully');
    } catch (e, stackTrace) {
      print('âŒ [Database] Initialization error: $e');
      print('Stack trace: $stackTrace');
      rethrow; // Let caller handle initialization failures
    }
  }

  // Note: tasksDao and calendarEventsDao are automatically generated by Drift
  // when listed in @DriftDatabase annotation
  // Access them directly: database.tasksDao, database.calendarEventsDao

  /// Schema version - increment when making schema changes
  ///
  /// Version History:
  /// - 1: Initial schema (users, user_settings, sync_queue)
  /// - 2: Added tasks table for task management
  /// - 3: Added calendar_events table for calendar and scheduling
  /// - 4: Added people module (households, people, people_milestones, contact_log)
  @override
  int get schemaVersion => 4;

  /// Migration strategy for schema changes
  ///
  /// Called automatically when schemaVersion is incremented.
  /// Define migration logic for each version upgrade.
  ///
  /// Example for future migrations:
  /// ```dart
  /// @override
  /// MigrationStrategy get migration {
  ///   return MigrationStrategy(
  ///     onCreate: (Migrator m) async {
  ///       await m.createAll();
  ///     },
  ///     onUpgrade: (Migrator m, int from, int to) async {
  ///       if (from == 1) {
  ///         // Add new table in version 2
  ///         await m.createTable(tasks);
  ///       }
  ///       if (from <= 2) {
  ///         // Add column in version 3
  ///         await m.addColumn(users, users.profileImageUrl);
  ///       }
  ///     },
  ///   );
  /// }
  /// ```
  @override
  MigrationStrategy get migration {
    return MigrationStrategy(
      onCreate: (Migrator m) async {
        try {
          print('ðŸ”¨ [Database] Creating all tables...');
          // Create all tables on fresh install
          await m.createAll();
          print('âœ… [Database] All tables created successfully');
        } catch (e, stackTrace) {
          print('âŒ [Database] ERROR creating tables: $e');
          print('âŒ [Database] Stack trace: $stackTrace');
          rethrow;
        }
      },
      onUpgrade: (Migrator m, int from, int to) async {
        try {
          print('â¬†ï¸ [Database] Upgrading from version $from to $to');
          // Migration logic for schema changes
          if (from == 1) {
            // Add tasks table in version 2
            await m.createTable(tasks);
          }
          if (from <= 2) {
            // Add calendar_events table in version 3
            await m.createTable(calendarEvents);
          }
          if (from <= 3) {
            // Add people module tables in version 4
            await m.createTable(households);
            await m.createTable(people);
            await m.createTable(peopleMilestones);
            await m.createTable(contactLogTable);
          }
          print('âœ… [Database] Upgrade completed');
        } catch (e, stackTrace) {
          print('âŒ [Database] ERROR during upgrade: $e');
          print('âŒ [Database] Stack trace: $stackTrace');
          rethrow;
        }
      },
      // Note: PRAGMA foreign_keys is SQLite-specific and not supported on web (IndexedDB)
      // Foreign key constraints are enforced by the application layer instead
    );
  }

  // ============================================================================
  // CONVENIENCE METHODS - Add commonly used queries here
  // ============================================================================

  /// Get user by ID
  Future<User?> getUserById(String userId) async {
    return (select(users)..where((u) => u.id.equals(userId))).getSingleOrNull();
  }

  /// Get user by email
  Future<User?> getUserByEmail(String email) async {
    return (select(users)..where((u) => u.email.equals(email))).getSingleOrNull();
  }

  /// Get user settings for a specific user
  Future<UserSetting?> getUserSettings(String userId) async {
    return (select(userSettings)..where((s) => s.userId.equals(userId))).getSingleOrNull();
  }

  /// Get all pending sync queue entries (ordered by creation time)
  Future<List<SyncQueueEntry>> getPendingSyncQueue() async {
    return (select(syncQueue)..orderBy([(e) => OrderingTerm.asc(e.createdAt)])).get();
  }

  /// Get sync queue entries for a specific table
  Future<List<SyncQueueEntry>> getSyncQueueForTable(String table) async {
    return (select(syncQueue)
          ..where((e) => e.affectedTable.equals(table))
          ..orderBy([(e) => OrderingTerm.asc(e.createdAt)]))
        .get();
  }

  /// Remove sync queue entry after successful sync
  Future<int> removeSyncQueueEntry(int entryId) async {
    return (delete(syncQueue)..where((e) => e.id.equals(entryId))).go();
  }

  /// Increment retry count and update error message for failed sync
  Future<void> updateSyncQueueFailure(int entryId, String errorMessage) async {
    final entry = await (select(syncQueue)..where((e) => e.id.equals(entryId))).getSingleOrNull();
    if (entry != null) {
      await (update(syncQueue)..where((e) => e.id.equals(entryId))).write(
        SyncQueueCompanion(
          retryCount: Value(entry.retryCount + 1),
          lastError: Value(errorMessage),
        ),
      );
    }
  }

  /// Get all records with pending sync status (across all tables)
  ///
  /// This is useful for diagnostics and showing sync status to users.
  /// Returns count of unsynced records by table.
  Future<Map<String, int>> getPendingSyncCounts() async {
    final counts = <String, int>{};

    // Count pending users
    final pendingUsers = await (select(users)
          ..where((u) => u.syncStatus.equals('pending')))
        .get();
    if (pendingUsers.isNotEmpty) {
      counts['users'] = pendingUsers.length;
    }

    // Count pending user settings
    final pendingSettings = await (select(userSettings)
          ..where((s) => s.syncStatus.equals('pending')))
        .get();
    if (pendingSettings.isNotEmpty) {
      counts['user_settings'] = pendingSettings.length;
    }

    // Count pending tasks (using DAO)
    final pendingTasks = await tasksDao.getPendingTasks();
    if (pendingTasks.isNotEmpty) {
      counts['tasks'] = pendingTasks.length;
    }

    return counts;
  }

  /// Mark a record as pending sync
  ///
  /// Call this after any local modification to trigger sync.
  /// Updates sync_status to 'pending' and sets local_updated_at timestamp.
  Future<void> markUserAsPending(String userId) async {
    await (update(users)..where((u) => u.id.equals(userId))).write(
      UsersCompanion(
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
        updatedAt: Value(DateTime.now().millisecondsSinceEpoch),
      ),
    );
  }

  /// Mark user settings as pending sync
  Future<void> markUserSettingsAsPending(String settingsId) async {
    await (update(userSettings)..where((s) => s.id.equals(settingsId))).write(
      UserSettingsCompanion(
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
        updatedAt: Value(DateTime.now().millisecondsSinceEpoch),
      ),
    );
  }

  /// Clear all data (for logout/account deletion)
  ///
  /// WARNING: This deletes ALL local data. Use with caution.
  /// Typically called during logout or account deletion.
  Future<void> clearAllData() async {
    await transaction(() async {
      await delete(syncQueue).go();
      await delete(userSettings).go();
      await delete(users).go();
      // Tasks will be deleted via CASCADE from users foreign key
    });
  }
}
