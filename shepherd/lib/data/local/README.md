# Shepherd Local Database - Drift Setup Guide

## Overview

This directory contains the local SQLite database implementation for the Shepherd app using **Drift** (formerly Moor). The database follows an **offline-first architecture** where all operations execute locally first, then sync to Supabase in the background.

## Architecture

```
lib/data/local/
‚îú‚îÄ‚îÄ database.dart              # Main AppDatabase class (singleton)
‚îú‚îÄ‚îÄ database.g.dart            # Generated by build_runner (DO NOT EDIT)
‚îú‚îÄ‚îÄ tables/
‚îÇ   ‚îú‚îÄ‚îÄ users_table.dart       # User profile table definition
‚îÇ   ‚îú‚îÄ‚îÄ user_settings_table.dart  # User preferences table definition
‚îÇ   ‚îî‚îÄ‚îÄ sync_queue_table.dart  # Sync queue for offline operations
‚îî‚îÄ‚îÄ README.md                  # This file
```

## Key Concepts

### 1. Offline-First Pattern

Every user action executes against the local database **immediately**, providing instant feedback. Changes are queued for background sync to Supabase:

```dart
// User completes a task
await database.updateTask(taskId, status: 'done');  // ‚úÖ Instant local update
await database.addToSyncQueue(...);                 // üì§ Queue for sync
// User sees completion immediately, sync happens in background
```

### 2. Sync Metadata

Every table includes four sync-related columns:

- **sync_status**: `'synced'`, `'pending'`, or `'conflict'`
- **local_updated_at**: Unix timestamp (ms) when locally modified
- **server_updated_at**: Unix timestamp (ms) of last known server state
- **version**: Integer for optimistic locking (conflict detection)

### 3. Sync Queue

The `sync_queue` table tracks all pending operations:

```dart
class SyncQueueEntry {
  int id;                    // Auto-increment primary key
  String affectedTable;      // 'users', 'user_settings', 'tasks', etc.
  String recordId;           // UUID of the affected record
  String operation;          // 'insert', 'update', 'delete'
  String? payload;           // JSON data to sync
  int createdAt;             // Unix timestamp
  int retryCount;            // Number of retry attempts
  String? lastError;         // Error from last failed attempt
}
```

## Initial Setup

### Step 1: Install Dependencies

The required packages are already in `pubspec.yaml`:

```yaml
dependencies:
  drift: ^2.14.0
  sqlite3_flutter_libs: ^0.5.0
  path_provider: ^2.1.0
  path: ^1.8.3
  uuid: ^4.0.0

dev_dependencies:
  build_runner: ^2.4.0
  drift_dev: ^2.14.0
```

Ensure they're installed:

```bash
cd c:\Users\Valdez\pastorapp\shepherd
flutter pub get
```

### Step 2: Generate Database Code

Drift uses code generation to create type-safe database classes. Run:

```bash
flutter pub run build_runner build --delete-conflicting-outputs
```

This generates `database.g.dart` with:
- `_$AppDatabase` base class
- `User`, `UserSetting`, `SyncQueueEntry` data classes
- `UsersCompanion`, `UserSettingsCompanion`, etc. for updates
- Type-safe query methods

**Expected output:**
```
[INFO] Generating build script...
[INFO] Generating build script completed, took 2.1s
[INFO] Creating build script snapshot...
[INFO] Creating build script snapshot completed, took 3.4s
[INFO] Running build...
[INFO] 1.2s elapsed, 1/1 actions completed.
[INFO] Running build completed, took 5.6s
[INFO] Caching finalized dependency graph...
[INFO] Caching finalized dependency graph completed, took 42ms
[SUCCESS] Build succeeded!
```

### Step 3: Verify Setup

After generation, all IDE errors should disappear. Verify the database works:

```dart
import 'package:shepherd/data/local/database.dart';

void main() async {
  final db = AppDatabase();

  // Database is ready to use!
  print('Database initialized successfully');

  // Example: Get all users
  final users = await db.select(db.users).get();
  print('Users count: ${users.length}');
}
```

## Usage Examples

### Creating a User

```dart
final db = AppDatabase();

// Create user with auto-generated UUID
final user = UsersCompanion.insert(
  email: 'pastor@church.com',
  name: 'John Smith',
  churchName: const Value('First Baptist Church'),
  timezone: const Value('America/New_York'),
);

final userId = await db.into(db.users).insert(user);
```

### Querying with Filters

```dart
// Get user by email
final user = await (db.select(db.users)
  ..where((u) => u.email.equals('pastor@church.com'))
).getSingleOrNull();

// Get all pending sync records
final pendingUsers = await (db.select(db.users)
  ..where((u) => u.syncStatus.equals('pending'))
).get();
```

### Updating Records

```dart
// Update user name and mark as pending sync
await (db.update(db.users)..where((u) => u.id.equals(userId))).write(
  UsersCompanion(
    name: const Value('John David Smith'),
    syncStatus: const Value('pending'),
    localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
  ),
);
```

### Using Convenience Methods

The `AppDatabase` class provides helper methods:

```dart
// Get user by ID
final user = await db.getUserById(userId);

// Get user settings
final settings = await db.getUserSettings(userId);

// Get pending sync queue
final queue = await db.getPendingSyncQueue();

// Mark user as needing sync
await db.markUserAsPending(userId);
```

### Working with User Settings

```dart
// Create default settings for new user
final settings = UserSettingsCompanion.insert(
  userId: userId,
  elderContactFrequencyDays: const Value(30),
  memberContactFrequencyDays: const Value(90),
  crisisContactFrequencyDays: const Value(3),
  weeklySermonPrepHours: const Value(8),
  notificationPreferences: Value(jsonEncode({
    'email': true,
    'push': true,
    'dailyDigest': '08:00',
  })),
);

await db.into(db.userSettings).insert(settings);

// Update notification preferences
final prefs = jsonEncode({'email': false, 'push': true});
await (db.update(db.userSettings)..where((s) => s.userId.equals(userId)))
  .write(UserSettingsCompanion(
    notificationPreferences: Value(prefs),
    syncStatus: const Value('pending'),
  ));
```

### Adding to Sync Queue

```dart
// Queue an operation for background sync
await db.into(db.syncQueue).insert(
  SyncQueueCompanion.insert(
    affectedTable: 'users',
    recordId: userId,
    operation: 'update',
    payload: Value(jsonEncode({
      'name': 'Updated Name',
      'church_name': 'New Church',
    })),
    createdAt: DateTime.now().millisecondsSinceEpoch,
  ),
);
```

## Development Workflow

### When Adding New Tables

1. **Create table definition** in `tables/` directory:
   ```dart
   @DataClassName('Task')
   class Tasks extends Table {
     TextColumn get id => text().clientDefault(() => const Uuid().v4())();
     TextColumn get userId => text().references(Users, #id)();
     TextColumn get title => text()();
     // ... other columns

     // Always include sync metadata
     TextColumn get syncStatus => text().withDefault(const Constant('synced'))();
     IntColumn get localUpdatedAt => integer().nullable()();
     IntColumn get serverUpdatedAt => integer().nullable()();
     IntColumn get version => integer().withDefault(const Constant(1))();

     @override
     Set<Column> get primaryKey => {id};
   }
   ```

2. **Import in database.dart**:
   ```dart
   import 'tables/tasks_table.dart';
   ```

3. **Add to @DriftDatabase annotation**:
   ```dart
   @DriftDatabase(
     tables: [
       Users,
       UserSettings,
       SyncQueue,
       Tasks,  // Add here
     ],
   )
   ```

4. **Increment schema version** in `database.dart`:
   ```dart
   @override
   int get schemaVersion => 2;  // Was 1, now 2
   ```

5. **Add migration logic**:
   ```dart
   onUpgrade: (Migrator m, int from, int to) async {
     if (from == 1) {
       await m.createTable(tasks);
     }
   },
   ```

6. **Regenerate code**:
   ```bash
   flutter pub run build_runner build --delete-conflicting-outputs
   ```

### When Modifying Existing Tables

**Adding a column:**

```dart
// 1. Add column to table definition
class Users extends Table {
  // ... existing columns
  TextColumn get profileImageUrl => text().nullable()();
}

// 2. Increment schema version
@override
int get schemaVersion => 2;

// 3. Add migration
onUpgrade: (Migrator m, int from, int to) async {
  if (from == 1) {
    await m.addColumn(users, users.profileImageUrl);
  }
},

// 4. Regenerate
flutter pub run build_runner build --delete-conflicting-outputs
```

**Renaming a column:**

```dart
// 1. Create new column
await m.addColumn(users, users.fullName);

// 2. Copy data
await customStatement('UPDATE users SET full_name = name');

// 3. Drop old column (SQLite requires table recreation)
// See Drift migration docs for complex table alterations
```

### Watching for Changes (Development)

During active development, use watch mode to auto-regenerate on file changes:

```bash
flutter pub run build_runner watch
```

This runs in the background and regenerates code whenever you modify table definitions.

**Note:** Press `Ctrl+C` to stop the watcher.

## Database Location

The SQLite database file is stored at:

- **Android**: `/data/data/com.shepherd.app/app_flutter/shepherd.sqlite`
- **iOS**: `<App Documents>/shepherd.sqlite`
- **Desktop**: `<User Documents>/shepherd.sqlite`

The exact path is logged on app startup. Look for:
```
Database location: /data/data/com.shepherd.app/app_flutter/shepherd.sqlite
```

## Debugging

### View Database Contents

**Option 1: Use SQLite CLI (ADB for Android)**

```bash
# Android
adb shell
run-as com.shepherd.app
cd app_flutter
sqlite3 shepherd.sqlite

# View tables
.tables

# Query data
SELECT * FROM users;
SELECT * FROM sync_queue;
```

**Option 2: Export Database for Inspection**

```bash
# Android - pull database to desktop
adb pull /data/data/com.shepherd.app/app_flutter/shepherd.sqlite ~/Desktop/

# Open with DB Browser for SQLite or similar tool
```

**Option 3: Add Debug Queries**

```dart
// In your Flutter code
final db = AppDatabase();

// Print all users
final users = await db.select(db.users).get();
for (final user in users) {
  print('User: ${user.email} - ${user.name}');
}

// Print sync queue
final queue = await db.getPendingSyncQueue();
print('Pending sync operations: ${queue.length}');
```

### Common Issues

**Build Runner Fails:**
```bash
# Clean and rebuild
flutter clean
flutter pub get
flutter pub run build_runner build --delete-conflicting-outputs
```

**Database Locked Error:**
```dart
// Close all database connections before testing
await db.close();
```

**Migration Errors:**
```dart
// To start fresh during development (deletes all data!)
await db.close();
final dbFolder = await getApplicationDocumentsDirectory();
final file = File(p.join(dbFolder.path, 'shepherd.sqlite'));
await file.delete();
// Restart app - fresh database will be created
```

## Performance Considerations

### Indexes

All foreign keys are automatically indexed by Drift. Add custom indexes for frequently queried columns:

```dart
class Tasks extends Table {
  // ... columns

  @override
  List<Set<Column>> get uniqueKeys => [
    {userId, title},  // Composite unique constraint
  ];
}

// For complex indexes, use customStatement in migration:
await customStatement('''
  CREATE INDEX idx_tasks_status_due_date
  ON tasks(user_id, status, due_date)
  WHERE deleted_at IS NULL
''');
```

### Batch Operations

Use transactions for multiple related operations:

```dart
await db.transaction(() async {
  // All or nothing - if any fails, all rollback
  await db.into(db.users).insert(user);
  await db.into(db.userSettings).insert(settings);
  await db.into(db.syncQueue).insert(queueEntry);
});
```

### Query Optimization

```dart
// BAD: Loads entire table into memory
final allUsers = await db.select(db.users).get();
final filtered = allUsers.where((u) => u.name.startsWith('J'));

// GOOD: Filter in SQL
final filtered = await (db.select(db.users)
  ..where((u) => u.name.like('J%'))
).get();
```

## Testing

### Unit Testing with In-Memory Database

```dart
import 'package:drift/native.dart';
import 'package:test/test.dart';

void main() {
  late AppDatabase db;

  setUp(() {
    // Create in-memory database for each test
    db = AppDatabase.testConstructor(NativeDatabase.memory());
  });

  tearDown(() async {
    await db.close();
  });

  test('inserting user works', () async {
    final user = UsersCompanion.insert(
      email: 'test@example.com',
      name: 'Test User',
    );

    await db.into(db.users).insert(user);

    final users = await db.select(db.users).get();
    expect(users.length, 1);
    expect(users.first.email, 'test@example.com');
  });
}
```

**Note:** You'll need to add a test constructor to `AppDatabase`:

```dart
// In database.dart
AppDatabase.testConstructor(QueryExecutor e) : super(e);
```

## Next Steps

1. ‚úÖ Tables created: `users`, `user_settings`, `sync_queue`
2. ‚è≥ Run `build_runner` to generate code
3. ‚è≥ Add more tables: `tasks`, `calendar_events`, `people`, `contact_logs`, etc.
4. ‚è≥ Implement sync engine to process `sync_queue`
5. ‚è≥ Add conflict resolution logic
6. ‚è≥ Build repository layer on top of database

## References

- **Drift Documentation**: https://drift.simonbinder.eu/
- **Technical Specification**: `c:\Users\Valdez\pastorapp\shepherd_technical_specification.md`
- **Drift Migrations**: https://drift.simonbinder.eu/docs/advanced-features/migrations/
- **SQLite Documentation**: https://www.sqlite.org/docs.html

## Support

For issues or questions about the database setup:
1. Check Drift documentation for API questions
2. Review technical specification for schema requirements
3. Verify `build_runner` generated code successfully
4. Check database file location and permissions
