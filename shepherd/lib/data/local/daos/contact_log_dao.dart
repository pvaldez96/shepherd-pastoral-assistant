// lib/data/local/daos/contact_log_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/contact_log_table.dart';

// This will be generated by build_runner
part 'contact_log_dao.g.dart';

/// Data Access Object for Contact Log table
///
/// Provides comprehensive CRUD operations and specialized queries for contact logging.
/// Contact logs track all pastoral contacts with people, enabling automatic pastoral
/// care tracking and contact frequency monitoring.
///
/// Key features:
/// - Basic CRUD (create, read, delete - no update since logs are immutable)
/// - Contact history queries by person
/// - Date-based filtering (today, this week, month, date range)
/// - Contact type filtering (visit, call, email, text, in_person, other)
/// - Time tracking (duration minutes)
/// - Sync support (pending, synced, conflict states)
/// - Reactive streams for real-time UI updates
///
/// Usage example:
/// ```dart
/// final db = AppDatabase();
/// final contactLogDao = ContactLogDao(db);
///
/// // Get all contacts for a person
/// final contacts = await contactLogDao.getContactsForPerson(personId);
///
/// // Log a new contact
/// final log = ContactLogCompanion(
///   id: Value(Uuid().v4()),
///   userId: Value(userId),
///   personId: Value(personId),
///   contactDate: Value(DateTime.now()),
///   contactType: const Value('visit'),
///   durationMinutes: const Value(45),
///   notes: const Value('Hospital visit - discussed recovery'),
/// );
/// await contactLogDao.insertContactLog(log);
/// ```
@DriftAccessor(tables: [ContactLogTable])
class ContactLogDao extends DatabaseAccessor<AppDatabase> with _$ContactLogDaoMixin {
  ContactLogDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all contact logs for a user (ordered by date descending, most recent first)
  ///
  /// Returns contact logs ordered by date descending
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of all contact logs
  Future<List<ContactLog>> getAllContactLogs(String userId) {
    return (select(contactLogTable)
          ..where((c) => c.userId.equals(userId))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  /// Get a single contact log by ID
  ///
  /// Returns null if log doesn't exist
  ///
  /// Parameters:
  /// - id: The contact log's UUID
  ///
  /// Returns: ContactLog or null
  Future<ContactLog?> getContactLogById(String id) {
    return (select(contactLogTable)..where((c) => c.id.equals(id))).getSingleOrNull();
  }

  /// Insert a new contact log
  ///
  /// Automatically sets sync metadata:
  /// - syncStatus = 'pending' (requires sync to server)
  /// - localUpdatedAt = current timestamp
  /// - version = 1 (initial version)
  ///
  /// IMPORTANT: When synced to Supabase, a trigger will automatically update
  /// people.last_contact_date if this contact_date is more recent.
  ///
  /// Parameters:
  /// - contactLog: ContactLogCompanion with log data
  ///
  /// Returns: Row ID of inserted contact log
  ///
  /// Example:
  /// ```dart
  /// final log = ContactLogCompanion(
  ///   id: Value(Uuid().v4()),
  ///   userId: Value(userId),
  ///   personId: Value(personId),
  ///   contactDate: Value(DateTime.now()),
  ///   contactType: const Value('call'),
  ///   durationMinutes: const Value(15),
  ///   notes: const Value('Follow-up call about prayer request'),
  /// );
  /// await contactLogDao.insertContactLog(log);
  /// ```
  Future<int> insertContactLog(ContactLogTableCompanion contactLog) {
    return into(contactLogTable).insert(contactLog);
  }

  /// Delete a contact log (hard delete - permanently removes from database)
  ///
  /// WARNING: This is irreversible. Contact logs are typically immutable,
  /// but this method allows deletion for corrections or privacy compliance.
  ///
  /// Note: Deleting a contact log does NOT automatically recalculate
  /// people.last_contact_date. That must be handled separately if needed.
  ///
  /// Parameters:
  /// - id: The contact log's UUID
  ///
  /// Returns: Number of rows deleted (0 or 1)
  Future<int> deleteContactLog(String id) {
    return (delete(contactLogTable)..where((c) => c.id.equals(id))).go();
  }

  // ============================================================================
  // PERSON-SPECIFIC QUERIES
  // ============================================================================

  /// Get all contact logs for a specific person (ordered by date descending)
  ///
  /// This is the primary query for viewing a person's contact history
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: List of contact logs for that person, most recent first
  Future<List<ContactLog>> getContactsForPerson(String personId) {
    return (select(contactLogTable)
          ..where((c) => c.personId.equals(personId))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  /// Get most recent contact log for a person
  ///
  /// Useful for determining last contact date and type
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: Most recent contact log or null if no contacts
  Future<ContactLog?> getMostRecentContactForPerson(String personId) {
    return (select(contactLogTable)
          ..where((c) => c.personId.equals(personId))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ])
          ..limit(1))
        .getSingleOrNull();
  }

  /// Count total contacts for a person
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: Total contact count
  Future<int> countContactsForPerson(String personId) async {
    final query = select(contactLogTable)..where((c) => c.personId.equals(personId));
    final result = await query.get();
    return result.length;
  }

  // ============================================================================
  // DATE-BASED QUERIES
  // ============================================================================

  /// Get contact logs for a specific date (day view)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - date: The date to query (time portion ignored)
  ///
  /// Returns: List of contacts on that date
  Future<List<ContactLog>> getContactsForDate(String userId, DateTime date) {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (select(contactLogTable)
          ..where((c) =>
              c.userId.equals(userId) &
              c.contactDate.isBiggerOrEqualValue(startOfDay) &
              c.contactDate.isSmallerThanValue(endOfDay))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  /// Get contact logs in a date range
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start (inclusive)
  /// - endDate: Range end (exclusive)
  ///
  /// Returns: List of contacts in range
  Future<List<ContactLog>> getContactsInRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    return (select(contactLogTable)
          ..where((c) =>
              c.userId.equals(userId) &
              c.contactDate.isBiggerOrEqualValue(startDate) &
              c.contactDate.isSmallerThanValue(endDate))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  /// Get contact logs for today
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of today's contacts
  Future<List<ContactLog>> getTodayContacts(String userId) {
    return getContactsForDate(userId, DateTime.now());
  }

  /// Get contact logs for this week (Monday through Sunday)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of this week's contacts
  Future<List<ContactLog>> getWeekContacts(String userId) {
    final now = DateTime.now();
    // Calculate start of week (Monday)
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final startOfWeekDate = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    // Calculate end of week (Sunday)
    final endOfWeek = startOfWeekDate.add(const Duration(days: 7));

    return getContactsInRange(userId, startOfWeekDate, endOfWeek);
  }

  /// Get contact logs for a specific month
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - year: Year (e.g., 2025)
  /// - month: Month (1-12)
  ///
  /// Returns: List of contacts in that month
  Future<List<ContactLog>> getMonthContacts(String userId, int year, int month) {
    final startOfMonth = DateTime(year, month, 1);
    final endOfMonth = DateTime(year, month + 1, 1);

    return getContactsInRange(userId, startOfMonth, endOfMonth);
  }

  // ============================================================================
  // CONTACT TYPE QUERIES
  // ============================================================================

  /// Get contact logs by type
  ///
  /// Contact types: 'visit', 'call', 'email', 'text', 'in_person', 'other'
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - contactType: Type to filter by
  ///
  /// Returns: List of contacts of that type
  Future<List<ContactLog>> getContactsByType(String userId, String contactType) {
    return (select(contactLogTable)
          ..where((c) => c.userId.equals(userId) & c.contactType.equals(contactType))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  /// Count contacts by type
  ///
  /// Useful for analytics (e.g., "How many visits vs calls this month?")
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Map of contact type to count
  ///
  /// Example: {'visit': 12, 'call': 45, 'email': 23, ...}
  Future<Map<String, int>> countContactsByType(String userId) async {
    final allLogs = await (select(contactLogTable)..where((c) => c.userId.equals(userId))).get();

    final counts = <String, int>{};
    for (final log in allLogs) {
      counts[log.contactType] = (counts[log.contactType] ?? 0) + 1;
    }

    return counts;
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all contact logs pending sync to server
  ///
  /// Returns: List of contact logs awaiting sync
  Future<List<ContactLog>> getPendingContactLogs() {
    return (select(contactLogTable)..where((c) => c.syncStatus.equals('pending'))).get();
  }

  /// Mark a contact log as successfully synced
  ///
  /// Updates:
  /// - syncStatus = 'synced'
  /// - serverUpdatedAt = server's updated_at timestamp
  ///
  /// Parameters:
  /// - id: The contact log's UUID
  /// - serverUpdatedAt: Server's updated_at timestamp (Unix milliseconds)
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markContactLogAsSynced(String id, int serverUpdatedAt) {
    return (update(contactLogTable)..where((c) => c.id.equals(id))).write(
      ContactLogTableCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  /// Mark a contact log as conflicted (concurrent modifications)
  ///
  /// Parameters:
  /// - id: The contact log's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markContactLogAsConflicted(String id) {
    return (update(contactLogTable)..where((c) => c.id.equals(id))).write(
      const ContactLogTableCompanion(
        syncStatus: Value('conflict'),
      ),
    );
  }

  /// Get all contact logs with sync conflicts
  ///
  /// Returns: List of conflicted contact logs
  Future<List<ContactLog>> getConflictedContactLogs() {
    return (select(contactLogTable)..where((c) => c.syncStatus.equals('conflict'))).get();
  }

  // ============================================================================
  // REACTIVE STREAMS (for real-time UI updates)
  // ============================================================================

  /// Watch all contact logs for a user (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of contact log lists
  Stream<List<ContactLog>> watchAllContactLogs(String userId) {
    return (select(contactLogTable)
          ..where((c) => c.userId.equals(userId))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .watch();
  }

  /// Watch contact logs for a specific person (reactive stream)
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: Stream of contact log lists for that person
  Stream<List<ContactLog>> watchContactsForPerson(String personId) {
    return (select(contactLogTable)
          ..where((c) => c.personId.equals(personId))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .watch();
  }

  /// Watch contact logs for a date range (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start
  /// - endDate: Range end
  ///
  /// Returns: Stream of contact log lists in range
  Stream<List<ContactLog>> watchContactsInRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    return (select(contactLogTable)
          ..where((c) =>
              c.userId.equals(userId) &
              c.contactDate.isBiggerOrEqualValue(startDate) &
              c.contactDate.isSmallerThanValue(endDate))
          ..orderBy([
            (c) => OrderingTerm(
                  expression: c.contactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .watch();
  }

  // ============================================================================
  // ANALYTICS AND STATISTICS
  // ============================================================================

  /// Count total contact logs for a user
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Total count of contact logs
  Future<int> countContactLogs(String userId) async {
    final query = select(contactLogTable)..where((c) => c.userId.equals(userId));
    final result = await query.get();
    return result.length;
  }

  /// Get total contact duration (in minutes) for a date range
  ///
  /// Useful for time tracking and workload analysis
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start
  /// - endDate: Range end
  ///
  /// Returns: Total minutes spent in contacts
  Future<int> getTotalContactDuration(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    final logs = await getContactsInRange(userId, startDate, endDate);

    int totalMinutes = 0;
    for (final log in logs) {
      if (log.durationMinutes != null) {
        totalMinutes += log.durationMinutes!;
      }
    }

    return totalMinutes;
  }

  /// Get contact statistics summary for a date range
  ///
  /// Returns:
  /// - Total contacts
  /// - Contacts by type
  /// - Total duration (minutes)
  /// - Average duration per contact
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start
  /// - endDate: Range end
  ///
  /// Returns: Map with statistic keys and values
  Future<Map<String, dynamic>> getContactStatistics(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    final logs = await getContactsInRange(userId, startDate, endDate);

    int totalDuration = 0;
    int countWithDuration = 0;
    final typeCount = <String, int>{};

    for (final log in logs) {
      // Count by type
      typeCount[log.contactType] = (typeCount[log.contactType] ?? 0) + 1;

      // Sum durations
      if (log.durationMinutes != null) {
        totalDuration += log.durationMinutes!;
        countWithDuration++;
      }
    }

    final avgDuration = countWithDuration > 0 ? totalDuration / countWithDuration : 0.0;

    return {
      'total_contacts': logs.length,
      'by_type': typeCount,
      'total_duration_minutes': totalDuration,
      'average_duration_minutes': avgDuration.round(),
    };
  }
}
