// lib/data/local/daos/tasks_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/tasks_table.dart';

// This will be generated by build_runner
part 'tasks_dao.g.dart';

/// Data Access Object for Tasks table
///
/// Provides comprehensive CRUD operations and specialized queries for task management.
/// All queries respect soft-delete pattern (filter out deleted_at IS NOT NULL).
///
/// Key features:
/// - Basic CRUD (create, read, update, delete)
/// - Status-based filtering (not_started, in_progress, done)
/// - Category filtering (sermon_prep, pastoral_care, etc.)
/// - Time-based queries (today, this week, overdue)
/// - Search capabilities
/// - Sync support (pending, synced, conflict states)
/// - Reactive streams for real-time UI updates
/// - Soft delete pattern (preserves deleted tasks for recovery)
///
/// Usage example:
/// ```dart
/// final db = AppDatabase();
/// final tasksDao = TasksDao(db);
///
/// // Get all active tasks
/// final tasks = await tasksDao.getAllTasks(userId);
///
/// // Create new task
/// final task = TasksCompanion(
///   id: Value(Uuid().v4()),
///   userId: Value(userId),
///   title: const Value('Prepare sermon'),
///   category: const Value('sermon_prep'),
///   priority: const Value('high'),
///   status: const Value('not_started'),
/// );
/// await tasksDao.insertTask(task);
///
/// // Watch tasks reactively
/// tasksDao.watchTasksByStatus(userId, 'not_started').listen((tasks) {
///   print('Active tasks: ${tasks.length}');
/// });
/// ```
@DriftAccessor(tables: [Tasks])
class TasksDao extends DatabaseAccessor<AppDatabase> with _$TasksDaoMixin {
  TasksDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all active tasks for a user (excludes soft-deleted tasks)
  ///
  /// Returns tasks ordered by due date (nulls last)
  /// Filters out soft-deleted tasks (deleted_at IS NULL)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of all active tasks
  Future<List<Task>> getAllTasks(String userId) {
    return (select(tasks)
          ..where((t) => t.userId.equals(userId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get a single task by ID
  ///
  /// Returns null if task doesn't exist or is soft-deleted
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Task or null
  Future<Task?> getTaskById(String id) {
    return (select(tasks)
          ..where((t) => t.id.equals(id) & t.deletedAt.isNull()))
        .getSingleOrNull();
  }

  /// Insert a new task
  ///
  /// Automatically sets sync metadata:
  /// - syncStatus = 'pending' (requires sync to server)
  /// - localUpdatedAt = current timestamp
  /// - version = 1 (initial version)
  ///
  /// Parameters:
  /// - task: TasksCompanion with task data
  ///
  /// Returns: Row ID of inserted task
  ///
  /// Example:
  /// ```dart
  /// final task = TasksCompanion(
  ///   id: Value(Uuid().v4()),
  ///   userId: Value(userId),
  ///   title: const Value('Visit hospital patient'),
  ///   category: const Value('pastoral_care'),
  ///   priority: const Value('urgent'),
  /// );
  /// await tasksDao.insertTask(task);
  /// ```
  Future<int> insertTask(TasksCompanion task) {
    return into(tasks).insert(task);
  }

  /// Update an existing task
  ///
  /// IMPORTANT: Caller must update sync metadata:
  /// ```dart
  /// final updatedTask = task.copyWith(
  ///   title: 'New title',
  ///   syncStatus: 'pending',
  ///   localUpdatedAt: DateTime.now().millisecondsSinceEpoch,
  ///   version: task.version + 1,
  /// );
  /// await tasksDao.updateTask(updatedTask);
  /// ```
  ///
  /// Parameters:
  /// - task: Complete Task object with updates
  ///
  /// Returns: true if update succeeded, false if task not found
  Future<bool> updateTask(Task task) {
    return update(tasks).replace(task);
  }

  /// Soft delete a task (sets status='deleted', deleted_at=now)
  ///
  /// Does NOT physically remove the record from database.
  /// Allows task recovery and maintains audit trail.
  ///
  /// Updates:
  /// - status = 'deleted'
  /// - deleted_at = current timestamp
  /// - syncStatus = 'pending' (sync deletion to server)
  /// - localUpdatedAt = current timestamp
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Number of rows affected (0 or 1)
  ///
  /// Example:
  /// ```dart
  /// await tasksDao.deleteTask(taskId);
  /// // Task still in database but filtered from queries
  /// // Can be recovered by setting status back to previous state
  /// ```
  Future<int> deleteTask(String id) {
    final now = DateTime.now();
    return (update(tasks)..where((t) => t.id.equals(id))).write(
      TasksCompanion(
        status: const Value('deleted'),
        deletedAt: Value(now),
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(now.millisecondsSinceEpoch),
        updatedAt: Value(now.millisecondsSinceEpoch),
      ),
    );
  }

  /// Hard delete a task (permanently removes from database)
  ///
  /// WARNING: This is irreversible. Only use for:
  /// - Sync cleanup (after server confirms deletion)
  /// - Purging old soft-deleted tasks past retention period
  ///
  /// Prefer soft delete (deleteTask) for user-initiated deletions.
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Number of rows deleted (0 or 1)
  Future<int> hardDeleteTask(String id) {
    return (delete(tasks)..where((t) => t.id.equals(id))).go();
  }

  // ============================================================================
  // STATUS-BASED QUERIES
  // ============================================================================

  /// Get all tasks with a specific status
  ///
  /// Common status values:
  /// - 'not_started': Tasks that haven't been started
  /// - 'in_progress': Currently active tasks
  /// - 'done': Completed tasks
  ///
  /// Excludes soft-deleted tasks
  /// Ordered by due date (soonest first, nulls last)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - status: Status value ('not_started', 'in_progress', 'done')
  ///
  /// Returns: List of tasks matching status
  Future<List<Task>> getTasksByStatus(String userId, String status) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.status.equals(status) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get overdue tasks (past due date, not completed)
  ///
  /// Criteria:
  /// - due_date < current date
  /// - status != 'done'
  /// - deleted_at IS NULL
  ///
  /// Ordered by due date (most overdue first)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of overdue tasks
  Future<List<Task>> getOverdueTasks(String userId) {
    final now = DateTime.now();
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.dueDate.isSmallerThanValue(now) &
              t.status.isNotValue('done') &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get tasks due today
  ///
  /// Criteria:
  /// - due_date between start of today and end of today
  /// - deleted_at IS NULL
  ///
  /// Ordered by due time if available, otherwise due date
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of today's tasks
  Future<List<Task>> getTodayTasks(String userId) {
    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.dueDate.isBiggerOrEqualValue(startOfDay) &
              t.dueDate.isSmallerThanValue(endOfDay) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get tasks due this week
  ///
  /// Week starts on Monday (ISO 8601 standard)
  ///
  /// Criteria:
  /// - due_date between start of this week and end of this week
  /// - deleted_at IS NULL
  ///
  /// Ordered by due date
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of this week's tasks
  Future<List<Task>> getWeekTasks(String userId) {
    final now = DateTime.now();
    // Calculate start of week (Monday)
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final startOfWeekDate =
        DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    // Calculate end of week (Sunday)
    final endOfWeek = startOfWeekDate.add(const Duration(days: 7));

    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.dueDate.isBiggerOrEqualValue(startOfWeekDate) &
              t.dueDate.isSmallerThanValue(endOfWeek) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Mark a task as completed
  ///
  /// Updates:
  /// - status = 'done'
  /// - completed_at = current timestamp
  /// - syncStatus = 'pending'
  /// - localUpdatedAt = current timestamp
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markTaskAsCompleted(String id) {
    final now = DateTime.now();
    return (update(tasks)..where((t) => t.id.equals(id))).write(
      TasksCompanion(
        status: const Value('done'),
        completedAt: Value(now),
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(now.millisecondsSinceEpoch),
        updatedAt: Value(now.millisecondsSinceEpoch),
      ),
    );
  }

  /// Mark a task as in progress
  ///
  /// Updates:
  /// - status = 'in_progress'
  /// - syncStatus = 'pending'
  /// - localUpdatedAt = current timestamp
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markTaskAsInProgress(String id) {
    final now = DateTime.now();
    return (update(tasks)..where((t) => t.id.equals(id))).write(
      TasksCompanion(
        status: const Value('in_progress'),
        syncStatus: const Value('pending'),
        localUpdatedAt: Value(now.millisecondsSinceEpoch),
        updatedAt: Value(now.millisecondsSinceEpoch),
      ),
    );
  }

  // ============================================================================
  // CATEGORY-BASED QUERIES
  // ============================================================================

  /// Get all tasks in a specific category
  ///
  /// Categories:
  /// - 'sermon_prep': Sermon preparation tasks
  /// - 'pastoral_care': Pastoral care and counseling
  /// - 'admin': Administrative tasks
  /// - 'personal': Personal development
  /// - 'worship_planning': Worship service planning
  ///
  /// Excludes soft-deleted tasks
  /// Ordered by due date
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - category: Category value
  ///
  /// Returns: List of tasks in category
  Future<List<Task>> getTasksByCategory(String userId, String category) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.category.equals(category) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get tasks by priority level
  ///
  /// Priority levels:
  /// - 'low': Can wait
  /// - 'medium': Normal priority
  /// - 'high': Important
  /// - 'urgent': Critical, immediate attention
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - priority: Priority level
  ///
  /// Returns: List of tasks with specified priority
  Future<List<Task>> getTasksByPriority(String userId, String priority) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.priority.equals(priority) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // RELATIONSHIP QUERIES
  // ============================================================================

  /// Get tasks related to a specific person
  ///
  /// Example: Find all pastoral care tasks for "John Smith"
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: List of tasks linked to that person
  Future<List<Task>> getTasksByPerson(String personId) {
    return (select(tasks)
          ..where((t) => t.personId.equals(personId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get tasks related to a specific sermon
  ///
  /// Example: Find all preparation tasks for "Sunday Sermon on John 3:16"
  ///
  /// Parameters:
  /// - sermonId: UUID of the sermon
  ///
  /// Returns: List of tasks linked to that sermon
  Future<List<Task>> getTasksBySermon(String sermonId) {
    return (select(tasks)
          ..where((t) => t.sermonId.equals(sermonId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get tasks related to a specific calendar event
  ///
  /// Example: Find preparation tasks for upcoming board meeting
  ///
  /// Parameters:
  /// - eventId: UUID of the calendar event
  ///
  /// Returns: List of tasks linked to that event
  Future<List<Task>> getTasksByEvent(String eventId) {
    return (select(tasks)
          ..where(
              (t) => t.calendarEventId.equals(eventId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get subtasks for a parent task
  ///
  /// Example: Get all subtasks for "Prepare Sunday Sermon"
  ///
  /// Parameters:
  /// - parentTaskId: UUID of parent task
  ///
  /// Returns: List of child tasks
  Future<List<Task>> getSubtasks(String parentTaskId) {
    return (select(tasks)
          ..where((t) =>
              t.parentTaskId.equals(parentTaskId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.createdAt,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // SEARCH AND FILTER
  // ============================================================================

  /// Search tasks by title (case-insensitive partial match)
  ///
  /// Uses LIKE query for flexible searching
  /// Example: "sermon" matches "Prepare Sunday Sermon"
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Search term (will be wrapped in % for partial match)
  ///
  /// Returns: List of matching tasks
  Future<List<Task>> searchTasks(String userId, String query) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.title.contains(query) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get tasks requiring focus time
  ///
  /// Returns tasks where requires_focus = true
  /// Useful for scheduling dedicated focus blocks
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of focus-requiring tasks
  Future<List<Task>> getFocusTasks(String userId) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.requiresFocus.equals(true) &
              t.status.isNotValue('done') &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  /// Get tasks by energy level
  ///
  /// Energy levels: 'low', 'medium', 'high'
  /// Useful for matching tasks to current energy state
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - energyLevel: Energy level required
  ///
  /// Returns: List of tasks matching energy level
  Future<List<Task>> getTasksByEnergyLevel(String userId, String energyLevel) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.energyLevel.equals(energyLevel) &
              t.status.isNotValue('done') &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all tasks pending sync to server
  ///
  /// Returns tasks where sync_status = 'pending'
  /// Used by sync engine to identify what needs uploading
  ///
  /// Returns: List of tasks awaiting sync
  Future<List<Task>> getPendingTasks() {
    return (select(tasks)..where((t) => t.syncStatus.equals('pending'))).get();
  }

  /// Mark a task as successfully synced
  ///
  /// Updates:
  /// - syncStatus = 'synced'
  /// - serverUpdatedAt = server's updated_at timestamp
  ///
  /// Called after successful push to Supabase
  ///
  /// Parameters:
  /// - id: The task's UUID
  /// - serverUpdatedAt: Server's updated_at timestamp (Unix milliseconds)
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markTaskAsSynced(String id, int serverUpdatedAt) {
    return (update(tasks)..where((t) => t.id.equals(id))).write(
      TasksCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  /// Mark a task as conflicted (concurrent modifications)
  ///
  /// Updates:
  /// - syncStatus = 'conflict'
  ///
  /// Called when sync detects server has newer version
  /// Requires user to resolve conflict manually
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markTaskAsConflicted(String id) {
    return (update(tasks)..where((t) => t.id.equals(id))).write(
      const TasksCompanion(
        syncStatus: Value('conflict'),
      ),
    );
  }

  /// Get all tasks with sync conflicts
  ///
  /// Returns tasks where sync_status = 'conflict'
  /// Used to show conflict resolution UI to user
  ///
  /// Returns: List of conflicted tasks
  Future<List<Task>> getConflictedTasks() {
    return (select(tasks)..where((t) => t.syncStatus.equals('conflict'))).get();
  }

  /// Batch update sync status for multiple tasks
  ///
  /// Useful for marking multiple tasks as synced after bulk operation
  ///
  /// Parameters:
  /// - ids: List of task UUIDs
  /// - status: New sync status
  ///
  /// Returns: Number of rows updated
  Future<int> batchUpdateSyncStatus(List<String> ids, String status) async {
    int count = 0;
    for (final id in ids) {
      count += await (update(tasks)..where((t) => t.id.equals(id))).write(
        TasksCompanion(
          syncStatus: Value(status),
        ),
      );
    }
    return count;
  }

  // ============================================================================
  // REACTIVE STREAMS (for real-time UI updates)
  // ============================================================================

  /// Watch all tasks for a user (reactive stream)
  ///
  /// Returns a Stream that emits new list whenever tasks change
  /// Perfect for Flutter StreamBuilder or Provider
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of task lists
  ///
  /// Example:
  /// ```dart
  /// StreamBuilder<List<Task>>(
  ///   stream: tasksDao.watchAllTasks(userId),
  ///   builder: (context, snapshot) {
  ///     final tasks = snapshot.data ?? [];
  ///     return ListView.builder(...);
  ///   },
  /// )
  /// ```
  Stream<List<Task>> watchAllTasks(String userId) {
    return (select(tasks)
          ..where((t) => t.userId.equals(userId) & t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .watch();
  }

  /// Watch tasks by status (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - status: Status to filter by
  ///
  /// Returns: Stream of task lists
  Stream<List<Task>> watchTasksByStatus(String userId, String status) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.status.equals(status) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .watch();
  }

  /// Watch tasks by category (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - category: Category to filter by
  ///
  /// Returns: Stream of task lists
  Stream<List<Task>> watchTasksByCategory(String userId, String category) {
    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.category.equals(category) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                  nulls: NullsOrder.last,
                ),
          ]))
        .watch();
  }

  /// Watch today's tasks (reactive stream)
  ///
  /// Note: Stream emits when tasks change, but date boundary
  /// is calculated at query time. Consider using Timer to
  /// refresh at midnight for accurate "today" display.
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of today's tasks
  Stream<List<Task>> watchTodayTasks(String userId) {
    final now = DateTime.now();
    final startOfDay = DateTime(now.year, now.month, now.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.dueDate.isBiggerOrEqualValue(startOfDay) &
              t.dueDate.isSmallerThanValue(endOfDay) &
              t.deletedAt.isNull())
          ..orderBy([
            (t) => OrderingTerm(
                  expression: t.dueDate,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch single task by ID (reactive stream)
  ///
  /// Parameters:
  /// - id: The task's UUID
  ///
  /// Returns: Stream of single task (or null if not found)
  Stream<Task?> watchTask(String id) {
    return (select(tasks)
          ..where((t) => t.id.equals(id) & t.deletedAt.isNull()))
        .watchSingleOrNull();
  }

  // ============================================================================
  // ANALYTICS AND STATISTICS
  // ============================================================================

  /// Count tasks by status
  ///
  /// Useful for dashboard metrics
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - status: Status to count
  ///
  /// Returns: Count of tasks
  Future<int> countTasksByStatus(String userId, String status) async {
    final query = select(tasks)
      ..where((t) =>
          t.userId.equals(userId) &
          t.status.equals(status) &
          t.deletedAt.isNull());

    final result = await query.get();
    return result.length;
  }

  /// Count tasks by category
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - category: Category to count
  ///
  /// Returns: Count of tasks
  Future<int> countTasksByCategory(String userId, String category) async {
    final query = select(tasks)
      ..where((t) =>
          t.userId.equals(userId) &
          t.category.equals(category) &
          t.deletedAt.isNull());

    final result = await query.get();
    return result.length;
  }

  /// Get completion rate for a date range
  ///
  /// Calculates percentage of completed tasks vs total tasks
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Start of date range
  /// - endDate: End of date range
  ///
  /// Returns: Map with total, completed, and rate
  Future<Map<String, dynamic>> getCompletionRate(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    final allTasks = await (select(tasks)
          ..where((t) =>
              t.userId.equals(userId) &
              t.createdAt.isBiggerOrEqualValue(startDate.millisecondsSinceEpoch) &
              t.createdAt.isSmallerOrEqualValue(endDate.millisecondsSinceEpoch) &
              t.deletedAt.isNull()))
        .get();

    final completed = allTasks.where((t) => t.status == 'done').length;
    final total = allTasks.length;
    final rate = total > 0 ? (completed / total * 100).toStringAsFixed(1) : '0.0';

    return {
      'total': total,
      'completed': completed,
      'rate': rate,
    };
  }
}
