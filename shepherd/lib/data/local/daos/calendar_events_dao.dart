// lib/data/local/daos/calendar_events_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/calendar_events_table.dart';

// This will be generated by build_runner
part 'calendar_events_dao.g.dart';

/// Data Access Object for Calendar Events table
///
/// Provides comprehensive CRUD operations and specialized queries for calendar management.
/// All queries handle DateTime conversions (Unix milliseconds <-> Dart DateTime).
///
/// Key features:
/// - Basic CRUD (create, read, update, delete)
/// - Date-based filtering (today, this week, month, date range)
/// - Event type filtering (service, meeting, pastoral_visit, etc.)
/// - Person-related event queries
/// - Conflict detection (overlapping events)
/// - Search capabilities
/// - Sync support (pending, synced, conflict states)
/// - Reactive streams for real-time UI updates
/// - Analytics (event counts, time load, energy tracking)
///
/// Usage example:
/// ```dart
/// final db = AppDatabase();
/// final eventsDao = CalendarEventsDao(db);
///
/// // Get all events for a date range
/// final startDate = DateTime(2025, 12, 9);
/// final endDate = DateTime(2025, 12, 15);
/// final events = await eventsDao.getEventsInRange(userId, startDate, endDate);
///
/// // Create new event
/// final event = CalendarEventsCompanion(
///   id: Value(Uuid().v4()),
///   userId: Value(userId),
///   title: const Value('Sunday Worship Service'),
///   startDatetime: Value(DateTime(2025, 12, 14, 10, 0).millisecondsSinceEpoch),
///   endDatetime: Value(DateTime(2025, 12, 14, 11, 30).millisecondsSinceEpoch),
///   eventType: const Value('service'),
/// );
/// await eventsDao.insertEvent(event);
///
/// // Watch events reactively
/// eventsDao.watchEventsForDate(userId, DateTime.now()).listen((events) {
///   print('Today\'s events: ${events.length}');
/// });
/// ```
@DriftAccessor(tables: [CalendarEvents])
class CalendarEventsDao extends DatabaseAccessor<AppDatabase> with _$CalendarEventsDaoMixin {
  CalendarEventsDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all events for a user (ordered by start datetime)
  ///
  /// Returns all events for the user, oldest first
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of all events
  Future<List<CalendarEvent>> getAllEvents(String userId) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get a single event by ID
  ///
  /// Returns null if event doesn't exist
  ///
  /// Parameters:
  /// - id: The event's UUID
  ///
  /// Returns: CalendarEvent or null
  Future<CalendarEvent?> getEventById(String id) {
    return (select(calendarEvents)..where((e) => e.id.equals(id))).getSingleOrNull();
  }

  /// Insert a new event
  ///
  /// Automatically sets sync metadata:
  /// - syncStatus = 'pending' (requires sync to server)
  /// - localUpdatedAt = current timestamp
  /// - version = 1 (initial version)
  ///
  /// Parameters:
  /// - event: CalendarEventsCompanion with event data
  ///
  /// Returns: Row ID of inserted event
  ///
  /// Example:
  /// ```dart
  /// final event = CalendarEventsCompanion(
  ///   id: Value(Uuid().v4()),
  ///   userId: Value(userId),
  ///   title: const Value('Board Meeting'),
  ///   startDatetime: Value(DateTime(2025, 12, 17, 19, 0).millisecondsSinceEpoch),
  ///   endDatetime: Value(DateTime(2025, 12, 17, 21, 0).millisecondsSinceEpoch),
  ///   eventType: const Value('meeting'),
  ///   location: const Value('Fellowship Hall'),
  ///   requiresPreparation: const Value(true),
  ///   preparationBufferHours: const Value(3),
  /// );
  /// await eventsDao.insertEvent(event);
  /// ```
  Future<int> insertEvent(CalendarEventsCompanion event) {
    return into(calendarEvents).insert(event);
  }

  /// Update an existing event
  ///
  /// IMPORTANT: Caller must update sync metadata:
  /// ```dart
  /// final updatedEvent = event.copyWith(
  ///   title: 'New Title',
  ///   syncStatus: 'pending',
  ///   localUpdatedAt: DateTime.now().millisecondsSinceEpoch,
  ///   version: event.version + 1,
  /// );
  /// await eventsDao.updateEvent(updatedEvent);
  /// ```
  ///
  /// Parameters:
  /// - event: Complete CalendarEvent object with updates
  ///
  /// Returns: true if update succeeded, false if event not found
  Future<bool> updateEvent(CalendarEvent event) {
    return update(calendarEvents).replace(event);
  }

  /// Delete an event (hard delete - permanently removes from database)
  ///
  /// WARNING: This is irreversible. Unlike tasks, calendar events don't use
  /// soft delete by default. Consider if you need an archive pattern.
  ///
  /// Parameters:
  /// - id: The event's UUID
  ///
  /// Returns: Number of rows deleted (0 or 1)
  Future<int> deleteEvent(String id) {
    return (delete(calendarEvents)..where((e) => e.id.equals(id))).go();
  }

  // ============================================================================
  // DATE-BASED QUERIES
  // ============================================================================

  /// Get all events for a specific date (day view)
  ///
  /// Returns events that start on the specified date (ignoring time)
  /// Useful for day calendar view
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - date: The date to query (time portion ignored)
  ///
  /// Returns: List of events on that date, ordered by start time
  Future<List<CalendarEvent>> getEventsForDate(String userId, DateTime date) {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (select(calendarEvents)
          ..where((e) =>
              e.userId.equals(userId) &
              e.startDatetime.isBiggerOrEqualValue(startOfDay.millisecondsSinceEpoch) &
              e.startDatetime.isSmallerThanValue(endOfDay.millisecondsSinceEpoch))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get events in a date range (week view, month view, custom range)
  ///
  /// Returns events that start within the specified date range (inclusive)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start (inclusive)
  /// - endDate: Range end (exclusive)
  ///
  /// Returns: List of events in range, ordered by start datetime
  ///
  /// Example:
  /// ```dart
  /// // Get this week's events
  /// final startOfWeek = DateTime.now().subtract(Duration(days: DateTime.now().weekday - 1));
  /// final endOfWeek = startOfWeek.add(Duration(days: 7));
  /// final weekEvents = await eventsDao.getEventsInRange(userId, startOfWeek, endOfWeek);
  /// ```
  Future<List<CalendarEvent>> getEventsInRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    return (select(calendarEvents)
          ..where((e) =>
              e.userId.equals(userId) &
              e.startDatetime.isBiggerOrEqualValue(startDate.millisecondsSinceEpoch) &
              e.startDatetime.isSmallerThanValue(endDate.millisecondsSinceEpoch))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get events for today
  ///
  /// Convenience method for getEventsForDate(userId, DateTime.now())
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of today's events
  Future<List<CalendarEvent>> getTodayEvents(String userId) {
    return getEventsForDate(userId, DateTime.now());
  }

  /// Get events for this week (Monday through Sunday)
  ///
  /// Week starts on Monday (ISO 8601 standard)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of this week's events
  Future<List<CalendarEvent>> getWeekEvents(String userId) {
    final now = DateTime.now();
    // Calculate start of week (Monday)
    final startOfWeek = now.subtract(Duration(days: now.weekday - 1));
    final startOfWeekDate = DateTime(startOfWeek.year, startOfWeek.month, startOfWeek.day);
    // Calculate end of week (Sunday)
    final endOfWeek = startOfWeekDate.add(const Duration(days: 7));

    return getEventsInRange(userId, startOfWeekDate, endOfWeek);
  }

  /// Get events for a specific month
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - year: Year (e.g., 2025)
  /// - month: Month (1-12)
  ///
  /// Returns: List of events in that month
  Future<List<CalendarEvent>> getMonthEvents(String userId, int year, int month) {
    final startOfMonth = DateTime(year, month, 1);
    final endOfMonth = DateTime(year, month + 1, 1); // First day of next month

    return getEventsInRange(userId, startOfMonth, endOfMonth);
  }

  /// Get upcoming events (future events only, limited)
  ///
  /// Returns the next N events starting from now
  /// Useful for "Next up" widgets
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - limit: Maximum number of events to return (default: 10)
  ///
  /// Returns: List of upcoming events
  Future<List<CalendarEvent>> getUpcomingEvents(String userId, {int limit = 10}) {
    final now = DateTime.now();

    return (select(calendarEvents)
          ..where((e) =>
              e.userId.equals(userId) &
              e.startDatetime.isBiggerThanValue(now.millisecondsSinceEpoch))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ])
          ..limit(limit))
        .get();
  }

  // ============================================================================
  // EVENT TYPE QUERIES
  // ============================================================================

  /// Get events by type
  ///
  /// Event types: 'service', 'meeting', 'pastoral_visit', 'personal', 'work', 'family', 'blocked_time'
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - eventType: Event type to filter by
  ///
  /// Returns: List of events of that type, ordered by start datetime
  Future<List<CalendarEvent>> getEventsByType(String userId, String eventType) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId) & e.eventType.equals(eventType))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // RELATIONSHIP QUERIES
  // ============================================================================

  /// Get events related to a specific person
  ///
  /// Example: Find all pastoral visits for "John Smith"
  ///
  /// Parameters:
  /// - personId: UUID of the person
  ///
  /// Returns: List of events linked to that person
  Future<List<CalendarEvent>> getEventsByPerson(String personId) {
    return (select(calendarEvents)
          ..where((e) => e.personId.equals(personId))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // CONFLICT DETECTION
  // ============================================================================

  /// Find events that overlap with a given time slot
  ///
  /// Detects scheduling conflicts before creating new events
  ///
  /// An event conflicts if:
  /// - It starts before the proposed slot ends, AND
  /// - It ends after the proposed slot starts
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - proposedStart: Proposed event start time
  /// - proposedEnd: Proposed event end time
  /// - excludeEventId: Optional event ID to exclude (for update operations)
  ///
  /// Returns: List of conflicting events
  ///
  /// Example:
  /// ```dart
  /// final proposed = DateTime(2025, 12, 15, 14, 0);
  /// final proposedEnd = DateTime(2025, 12, 15, 16, 0);
  /// final conflicts = await eventsDao.findConflictingEvents(
  ///   userId,
  ///   proposed,
  ///   proposedEnd,
  /// );
  /// if (conflicts.isNotEmpty) {
  ///   print('Warning: ${conflicts.length} scheduling conflicts detected');
  /// }
  /// ```
  Future<List<CalendarEvent>> findConflictingEvents(
    String userId,
    DateTime proposedStart,
    DateTime proposedEnd, {
    String? excludeEventId,
  }) {
    final query = select(calendarEvents)
      ..where((e) =>
          e.userId.equals(userId) &
          e.startDatetime.isSmallerThanValue(proposedEnd.millisecondsSinceEpoch) &
          e.endDatetime.isBiggerThanValue(proposedStart.millisecondsSinceEpoch));

    // Exclude specific event (useful when updating an event)
    if (excludeEventId != null) {
      query.where((e) => e.id.isNotValue(excludeEventId));
    }

    query.orderBy([
      (e) => OrderingTerm(
            expression: e.startDatetime,
            mode: OrderingMode.asc,
          ),
    ]);

    return query.get();
  }

  // ============================================================================
  // SEARCH AND FILTER
  // ============================================================================

  /// Search events by title (case-insensitive partial match)
  ///
  /// Uses LIKE query for flexible searching
  /// Example: "board" matches "Board Meeting", "Outboard Motor Meeting"
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Search term (will be wrapped in % for partial match)
  ///
  /// Returns: List of matching events
  Future<List<CalendarEvent>> searchEvents(String userId, String query) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId) & e.title.contains(query))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get events requiring preparation
  ///
  /// Returns events where requires_preparation = true
  /// Useful for generating preparation task lists
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - futureOnly: If true, only return upcoming events (default: true)
  ///
  /// Returns: List of events requiring preparation
  Future<List<CalendarEvent>> getEventsRequiringPreparation(
    String userId, {
    bool futureOnly = true,
  }) {
    final query = select(calendarEvents)
      ..where((e) => e.userId.equals(userId) & e.requiresPreparation.equals(true));

    if (futureOnly) {
      final now = DateTime.now();
      query.where((e) => e.startDatetime.isBiggerThanValue(now.millisecondsSinceEpoch));
    }

    query.orderBy([
      (e) => OrderingTerm(
            expression: e.startDatetime,
            mode: OrderingMode.asc,
          ),
    ]);

    return query.get();
  }

  /// Get recurring events
  ///
  /// Returns events where is_recurring = true
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of recurring events
  Future<List<CalendarEvent>> getRecurringEvents(String userId) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId) & e.isRecurring.equals(true))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get non-moveable events (fixed commitments)
  ///
  /// Returns events where is_moveable = false
  /// Useful for identifying scheduling constraints
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Optional start date filter
  /// - endDate: Optional end date filter
  ///
  /// Returns: List of fixed events
  Future<List<CalendarEvent>> getFixedEvents(
    String userId, {
    DateTime? startDate,
    DateTime? endDate,
  }) {
    final query = select(calendarEvents)
      ..where((e) => e.userId.equals(userId) & e.isMoveable.equals(false));

    if (startDate != null) {
      query.where((e) => e.startDatetime.isBiggerOrEqualValue(startDate.millisecondsSinceEpoch));
    }
    if (endDate != null) {
      query.where((e) => e.startDatetime.isSmallerThanValue(endDate.millisecondsSinceEpoch));
    }

    query.orderBy([
      (e) => OrderingTerm(
            expression: e.startDatetime,
            mode: OrderingMode.asc,
          ),
    ]);

    return query.get();
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all events pending sync to server
  ///
  /// Returns events where sync_status = 'pending'
  /// Used by sync engine to identify what needs uploading
  ///
  /// Returns: List of events awaiting sync
  Future<List<CalendarEvent>> getPendingEvents() {
    return (select(calendarEvents)..where((e) => e.syncStatus.equals('pending'))).get();
  }

  /// Mark an event as successfully synced
  ///
  /// Updates:
  /// - syncStatus = 'synced'
  /// - serverUpdatedAt = server's updated_at timestamp
  ///
  /// Called after successful push to Supabase
  ///
  /// Parameters:
  /// - id: The event's UUID
  /// - serverUpdatedAt: Server's updated_at timestamp (Unix milliseconds)
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markEventAsSynced(String id, int serverUpdatedAt) {
    return (update(calendarEvents)..where((e) => e.id.equals(id))).write(
      CalendarEventsCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  /// Mark an event as conflicted (concurrent modifications)
  ///
  /// Updates:
  /// - syncStatus = 'conflict'
  ///
  /// Called when sync detects server has newer version
  /// Requires user to resolve conflict manually
  ///
  /// Parameters:
  /// - id: The event's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markEventAsConflicted(String id) {
    return (update(calendarEvents)..where((e) => e.id.equals(id))).write(
      const CalendarEventsCompanion(
        syncStatus: Value('conflict'),
      ),
    );
  }

  /// Get all events with sync conflicts
  ///
  /// Returns events where sync_status = 'conflict'
  /// Used to show conflict resolution UI to user
  ///
  /// Returns: List of conflicted events
  Future<List<CalendarEvent>> getConflictedEvents() {
    return (select(calendarEvents)..where((e) => e.syncStatus.equals('conflict'))).get();
  }

  /// Resolve a conflict by applying the resolved event data
  ///
  /// Updates the conflicted event with resolved data and marks as synced
  ///
  /// Parameters:
  /// - id: The event's UUID
  /// - resolved: CalendarEventsCompanion with resolved data
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> resolveConflict(String id, CalendarEventsCompanion resolved) {
    return (update(calendarEvents)..where((e) => e.id.equals(id))).write(resolved);
  }

  // ============================================================================
  // REACTIVE STREAMS (for real-time UI updates)
  // ============================================================================

  /// Watch all events for a user (reactive stream)
  ///
  /// Returns a Stream that emits new list whenever events change
  /// Perfect for Flutter StreamBuilder or Provider
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of event lists
  ///
  /// Example:
  /// ```dart
  /// StreamBuilder<List<CalendarEvent>>(
  ///   stream: eventsDao.watchAllEvents(userId),
  ///   builder: (context, snapshot) {
  ///     final events = snapshot.data ?? [];
  ///     return ListView.builder(...);
  ///   },
  /// )
  /// ```
  Stream<List<CalendarEvent>> watchAllEvents(String userId) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch events for a specific date (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - date: The date to watch (time portion ignored)
  ///
  /// Returns: Stream of event lists for that date
  Stream<List<CalendarEvent>> watchEventsForDate(String userId, DateTime date) {
    final startOfDay = DateTime(date.year, date.month, date.day);
    final endOfDay = startOfDay.add(const Duration(days: 1));

    return (select(calendarEvents)
          ..where((e) =>
              e.userId.equals(userId) &
              e.startDatetime.isBiggerOrEqualValue(startOfDay.millisecondsSinceEpoch) &
              e.startDatetime.isSmallerThanValue(endOfDay.millisecondsSinceEpoch))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch events in a date range (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start (inclusive)
  /// - endDate: Range end (exclusive)
  ///
  /// Returns: Stream of event lists in range
  Stream<List<CalendarEvent>> watchEventsInRange(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) {
    return (select(calendarEvents)
          ..where((e) =>
              e.userId.equals(userId) &
              e.startDatetime.isBiggerOrEqualValue(startDate.millisecondsSinceEpoch) &
              e.startDatetime.isSmallerThanValue(endDate.millisecondsSinceEpoch))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch events by type (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - eventType: Event type to filter by
  ///
  /// Returns: Stream of event lists of that type
  Stream<List<CalendarEvent>> watchEventsByType(String userId, String eventType) {
    return (select(calendarEvents)
          ..where((e) => e.userId.equals(userId) & e.eventType.equals(eventType))
          ..orderBy([
            (e) => OrderingTerm(
                  expression: e.startDatetime,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch today's events (reactive stream)
  ///
  /// Note: Stream emits when events change, but date boundary
  /// is calculated at query time. Consider using Timer to
  /// refresh at midnight for accurate "today" display.
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of today's events
  Stream<List<CalendarEvent>> watchTodayEvents(String userId) {
    return watchEventsForDate(userId, DateTime.now());
  }

  // ============================================================================
  // ANALYTICS AND STATISTICS
  // ============================================================================

  /// Count events by type
  ///
  /// Useful for dashboard metrics and time allocation analysis
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Map of event type to count
  ///
  /// Example output: {'service': 4, 'meeting': 12, 'pastoral_visit': 8}
  Future<Map<String, int>> countEventsByType(String userId) async {
    final events = await (select(calendarEvents)..where((e) => e.userId.equals(userId))).get();

    final counts = <String, int>{};
    for (final event in events) {
      counts[event.eventType] = (counts[event.eventType] ?? 0) + 1;
    }

    return counts;
  }

  /// Get total scheduled hours for a specific date
  ///
  /// Calculates sum of event durations for the date
  /// Useful for workload visualization
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - date: The date to analyze
  ///
  /// Returns: Total hours scheduled (as double)
  ///
  /// Example: 7.5 (7 hours and 30 minutes)
  Future<double> getEventLoadForDate(String userId, DateTime date) async {
    final events = await getEventsForDate(userId, date);

    double totalMinutes = 0;
    for (final event in events) {
      final start = DateTime.fromMillisecondsSinceEpoch(event.startDatetime);
      final end = DateTime.fromMillisecondsSinceEpoch(event.endDatetime);
      totalMinutes += end.difference(start).inMinutes;
    }

    return totalMinutes / 60.0;
  }

  /// Get event load for each day in a week
  ///
  /// Returns map of date to total hours scheduled
  /// Useful for week view workload visualization
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - weekStart: Start of the week (typically Monday)
  ///
  /// Returns: Map of DateTime (date only) to hours scheduled
  ///
  /// Example: {2025-12-09: 8.5, 2025-12-10: 6.0, 2025-12-11: 9.5, ...}
  Future<Map<DateTime, double>> getEventLoadForWeek(String userId, DateTime weekStart) async {
    final weekStartDate = DateTime(weekStart.year, weekStart.month, weekStart.day);
    final weekEnd = weekStartDate.add(const Duration(days: 7));

    final events = await getEventsInRange(userId, weekStartDate, weekEnd);

    final load = <DateTime, double>{};

    // Initialize all days in the week to 0
    for (int i = 0; i < 7; i++) {
      final date = weekStartDate.add(Duration(days: i));
      load[date] = 0.0;
    }

    // Calculate hours for each event
    for (final event in events) {
      final start = DateTime.fromMillisecondsSinceEpoch(event.startDatetime);
      final end = DateTime.fromMillisecondsSinceEpoch(event.endDatetime);
      final eventDate = DateTime(start.year, start.month, start.day);
      final hours = end.difference(start).inMinutes / 60.0;

      load[eventDate] = (load[eventDate] ?? 0.0) + hours;
    }

    return load;
  }

  /// Get energy expenditure summary for a date range
  ///
  /// Returns count of events by energy level
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - startDate: Range start
  /// - endDate: Range end
  ///
  /// Returns: Map of energy level to count
  ///
  /// Example: {'low': 5, 'medium': 12, 'high': 8}
  Future<Map<String, int>> getEnergyExpenditureSummary(
    String userId,
    DateTime startDate,
    DateTime endDate,
  ) async {
    final events = await getEventsInRange(userId, startDate, endDate);

    final counts = <String, int>{};
    for (final event in events) {
      counts[event.energyDrain] = (counts[event.energyDrain] ?? 0) + 1;
    }

    return counts;
  }
}