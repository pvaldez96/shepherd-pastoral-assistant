// lib/data/local/daos/households_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/households_table.dart';

// This will be generated by build_runner
part 'households_dao.g.dart';

/// Data Access Object for Households table
///
/// Provides comprehensive CRUD operations and specialized queries for household management.
/// Households group people by family units, making it easier to track pastoral care
/// at the household level.
///
/// Key features:
/// - Basic CRUD (create, read, update, delete)
/// - Search by name
/// - Get people count per household
/// - Sync support (pending, synced, conflict states)
/// - Reactive streams for real-time UI updates
///
/// Usage example:
/// ```dart
/// final db = AppDatabase();
/// final householdsDao = HouseholdsDao(db);
///
/// // Get all households for a user
/// final households = await householdsDao.getAllHouseholds(userId);
///
/// // Create new household
/// final household = HouseholdsCompanion(
///   id: Value(Uuid().v4()),
///   userId: Value(userId),
///   name: const Value('Smith Family'),
///   address: const Value('123 Main St, Springfield, IL 62701'),
/// );
/// await householdsDao.insertHousehold(household);
///
/// // Watch households reactively
/// householdsDao.watchAllHouseholds(userId).listen((households) {
///   print('Households: ${households.length}');
/// });
/// ```
@DriftAccessor(tables: [Households])
class HouseholdsDao extends DatabaseAccessor<AppDatabase> with _$HouseholdsDaoMixin {
  HouseholdsDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all households for a user (ordered by name)
  ///
  /// Returns households ordered alphabetically by name
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of all households
  Future<List<Household>> getAllHouseholds(String userId) {
    return (select(households)
          ..where((h) => h.userId.equals(userId))
          ..orderBy([
            (h) => OrderingTerm(
                  expression: h.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get a single household by ID
  ///
  /// Returns null if household doesn't exist
  ///
  /// Parameters:
  /// - id: The household's UUID
  ///
  /// Returns: Household or null
  Future<Household?> getHouseholdById(String id) {
    return (select(households)..where((h) => h.id.equals(id))).getSingleOrNull();
  }

  /// Insert a new household
  ///
  /// Automatically sets sync metadata:
  /// - syncStatus = 'pending' (requires sync to server)
  /// - localUpdatedAt = current timestamp
  /// - version = 1 (initial version)
  ///
  /// Parameters:
  /// - household: HouseholdsCompanion with household data
  ///
  /// Returns: Row ID of inserted household
  ///
  /// Example:
  /// ```dart
  /// final household = HouseholdsCompanion(
  ///   id: Value(Uuid().v4()),
  ///   userId: Value(userId),
  ///   name: const Value('Johnson Family'),
  ///   address: const Value('456 Oak Ave, Springfield, IL 62702'),
  /// );
  /// await householdsDao.insertHousehold(household);
  /// ```
  Future<int> insertHousehold(HouseholdsCompanion household) {
    return into(households).insert(household);
  }

  /// Update an existing household
  ///
  /// IMPORTANT: Caller must update sync metadata:
  /// ```dart
  /// final updatedHousehold = household.copyWith(
  ///   name: 'New Name',
  ///   syncStatus: 'pending',
  ///   localUpdatedAt: DateTime.now().millisecondsSinceEpoch,
  ///   version: household.version + 1,
  /// );
  /// await householdsDao.updateHousehold(updatedHousehold);
  /// ```
  ///
  /// Parameters:
  /// - household: Complete Household object with updates
  ///
  /// Returns: true if update succeeded, false if household not found
  Future<bool> updateHousehold(Household household) {
    return update(households).replace(household);
  }

  /// Delete a household (hard delete - permanently removes from database)
  ///
  /// WARNING: This is irreversible. When a household is deleted:
  /// - All people linked to this household will have household_id set to NULL
  ///   (ON DELETE SET NULL in Supabase)
  /// - The household record is permanently removed
  ///
  /// Parameters:
  /// - id: The household's UUID
  ///
  /// Returns: Number of rows deleted (0 or 1)
  Future<int> deleteHousehold(String id) {
    return (delete(households)..where((h) => h.id.equals(id))).go();
  }

  // ============================================================================
  // SEARCH AND FILTER
  // ============================================================================

  /// Search households by name (case-insensitive partial match)
  ///
  /// Uses LIKE query for flexible searching
  /// Example: "smith" matches "Smith Family", "The Smithsons"
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Search term (will be wrapped in % for partial match)
  ///
  /// Returns: List of matching households
  Future<List<Household>> searchHouseholds(String userId, String query) {
    return (select(households)
          ..where((h) => h.userId.equals(userId) & h.name.contains(query))
          ..orderBy([
            (h) => OrderingTerm(
                  expression: h.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all households pending sync to server
  ///
  /// Returns households where sync_status = 'pending'
  /// Used by sync engine to identify what needs uploading
  ///
  /// Returns: List of households awaiting sync
  Future<List<Household>> getPendingHouseholds() {
    return (select(households)..where((h) => h.syncStatus.equals('pending'))).get();
  }

  /// Mark a household as successfully synced
  ///
  /// Updates:
  /// - syncStatus = 'synced'
  /// - serverUpdatedAt = server's updated_at timestamp
  ///
  /// Called after successful push to Supabase
  ///
  /// Parameters:
  /// - id: The household's UUID
  /// - serverUpdatedAt: Server's updated_at timestamp (Unix milliseconds)
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markHouseholdAsSynced(String id, int serverUpdatedAt) {
    return (update(households)..where((h) => h.id.equals(id))).write(
      HouseholdsCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  /// Mark a household as conflicted (concurrent modifications)
  ///
  /// Updates:
  /// - syncStatus = 'conflict'
  ///
  /// Called when sync detects server has newer version
  /// Requires user to resolve conflict manually
  ///
  /// Parameters:
  /// - id: The household's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markHouseholdAsConflicted(String id) {
    return (update(households)..where((h) => h.id.equals(id))).write(
      const HouseholdsCompanion(
        syncStatus: Value('conflict'),
      ),
    );
  }

  /// Get all households with sync conflicts
  ///
  /// Returns households where sync_status = 'conflict'
  /// Used to show conflict resolution UI to user
  ///
  /// Returns: List of conflicted households
  Future<List<Household>> getConflictedHouseholds() {
    return (select(households)..where((h) => h.syncStatus.equals('conflict'))).get();
  }

  // ============================================================================
  // REACTIVE STREAMS (for real-time UI updates)
  // ============================================================================

  /// Watch all households for a user (reactive stream)
  ///
  /// Returns a Stream that emits new list whenever households change
  /// Perfect for Flutter StreamBuilder or Provider
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of household lists
  ///
  /// Example:
  /// ```dart
  /// StreamBuilder<List<Household>>(
  ///   stream: householdsDao.watchAllHouseholds(userId),
  ///   builder: (context, snapshot) {
  ///     final households = snapshot.data ?? [];
  ///     return ListView.builder(...);
  ///   },
  /// )
  /// ```
  Stream<List<Household>> watchAllHouseholds(String userId) {
    return (select(households)
          ..where((h) => h.userId.equals(userId))
          ..orderBy([
            (h) => OrderingTerm(
                  expression: h.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch single household by ID (reactive stream)
  ///
  /// Parameters:
  /// - id: The household's UUID
  ///
  /// Returns: Stream of single household (or null if not found)
  Stream<Household?> watchHousehold(String id) {
    return (select(households)..where((h) => h.id.equals(id))).watchSingleOrNull();
  }

  // ============================================================================
  // ANALYTICS AND STATISTICS
  // ============================================================================

  /// Count households for a user
  ///
  /// Useful for dashboard metrics
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Count of households
  Future<int> countHouseholds(String userId) async {
    final query = select(households)..where((h) => h.userId.equals(userId));
    final result = await query.get();
    return result.length;
  }
}
