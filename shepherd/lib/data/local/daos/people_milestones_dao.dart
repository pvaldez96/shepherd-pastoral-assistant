// lib/data/local/daos/people_milestones_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/people_milestones_table.dart';

// This will be generated by build_runner
part 'people_milestones_dao.g.dart';

/// Data Access Object for People Milestones table
///
/// Provides CRUD operations for milestone management.
/// Milestones track important dates for people (birthday, anniversary, surgery, etc.)
///
/// Key features:
/// - Basic CRUD (create, read, update, delete)
/// - Get milestones for a specific person
/// - Get upcoming milestones across all people
/// - Sync support
/// - Reactive streams for real-time UI updates
@DriftAccessor(tables: [PeopleMilestones])
class PeopleMilestonesDao extends DatabaseAccessor<AppDatabase> with _$PeopleMilestonesDaoMixin {
  PeopleMilestonesDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all milestones for a person (ordered by date)
  Future<List<PeopleMilestone>> getMilestones(String personId) {
    return (select(peopleMilestones)
          ..where((m) => m.personId.equals(personId))
          ..orderBy([
            (m) => OrderingTerm(
                  expression: m.date,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get a single milestone by ID
  Future<PeopleMilestone?> getMilestoneById(String id) {
    return (select(peopleMilestones)..where((m) => m.id.equals(id))).getSingleOrNull();
  }

  /// Insert a new milestone
  Future<int> insertMilestone(PeopleMilestonesCompanion milestone) {
    return into(peopleMilestones).insert(milestone);
  }

  /// Update an existing milestone
  Future<bool> updateMilestone(PeopleMilestone milestone) {
    return update(peopleMilestones).replace(milestone);
  }

  /// Delete a milestone
  Future<int> deleteMilestone(String id) {
    return (delete(peopleMilestones)..where((m) => m.id.equals(id))).go();
  }

  /// Delete all milestones for a person
  Future<int> deleteMilestonesForPerson(String personId) {
    return (delete(peopleMilestones)..where((m) => m.personId.equals(personId))).go();
  }

  // ============================================================================
  // UPCOMING MILESTONES
  // ============================================================================

  /// Get upcoming milestones across all people for a user
  ///
  /// Considers the next occurrence of each milestone (for recurring dates like birthdays)
  /// and returns those within the notification window.
  Future<List<PeopleMilestone>> getUpcomingMilestones(int daysAhead) async {
    // Get all milestones
    final allMilestones = await select(peopleMilestones).get();

    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    final upcoming = <PeopleMilestone>[];

    for (final milestone in allMilestones) {
      // Calculate next occurrence of milestone date (for recurring dates like birthdays)
      var thisYearDate = DateTime(now.year, milestone.date.month, milestone.date.day);

      // If this year's date has passed, check next year
      if (thisYearDate.isBefore(today)) {
        thisYearDate = DateTime(now.year + 1, milestone.date.month, milestone.date.day);
      }

      final daysUntil = thisYearDate.difference(today).inDays;

      // Include if within daysAhead window
      if (daysUntil >= 0 && daysUntil <= daysAhead) {
        upcoming.add(milestone);
      }
    }

    // Sort by days until next occurrence
    upcoming.sort((a, b) {
      final aDays = _daysUntilNextOccurrence(a.date);
      final bDays = _daysUntilNextOccurrence(b.date);
      return aDays.compareTo(bDays);
    });

    return upcoming;
  }

  int _daysUntilNextOccurrence(DateTime date) {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);
    var thisYearDate = DateTime(now.year, date.month, date.day);

    if (thisYearDate.isBefore(today)) {
      thisYearDate = DateTime(now.year + 1, date.month, date.day);
    }

    return thisYearDate.difference(today).inDays;
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all milestones pending sync
  Future<List<PeopleMilestone>> getPendingMilestones() {
    return (select(peopleMilestones)..where((m) => m.syncStatus.equals('pending'))).get();
  }

  /// Mark a milestone as synced
  Future<int> markMilestoneAsSynced(String id, int serverUpdatedAt) {
    return (update(peopleMilestones)..where((m) => m.id.equals(id))).write(
      PeopleMilestonesCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  // ============================================================================
  // REACTIVE STREAMS
  // ============================================================================

  /// Watch all milestones for a person
  Stream<List<PeopleMilestone>> watchMilestones(String personId) {
    return (select(peopleMilestones)
          ..where((m) => m.personId.equals(personId))
          ..orderBy([
            (m) => OrderingTerm(
                  expression: m.date,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch upcoming milestones
  Stream<List<PeopleMilestone>> watchUpcomingMilestones(int daysAhead) {
    // Watch all milestones and filter
    return select(peopleMilestones).watch().map((milestones) {
      final now = DateTime.now();
      final today = DateTime(now.year, now.month, now.day);

      return milestones.where((milestone) {
        var thisYearDate = DateTime(now.year, milestone.date.month, milestone.date.day);
        if (thisYearDate.isBefore(today)) {
          thisYearDate = DateTime(now.year + 1, milestone.date.month, milestone.date.day);
        }
        final daysUntil = thisYearDate.difference(today).inDays;
        return daysUntil >= 0 && daysUntil <= daysAhead;
      }).toList()
        ..sort((a, b) {
          final aDays = _daysUntilNextOccurrence(a.date);
          final bDays = _daysUntilNextOccurrence(b.date);
          return aDays.compareTo(bDays);
        });
    });
  }
}
