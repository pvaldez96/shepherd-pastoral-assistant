// lib/data/local/daos/people_dao.dart

import 'package:drift/drift.dart';
import '../database.dart';
import '../tables/people_table.dart';

// This will be generated by build_runner
part 'people_dao.g.dart';

/// Data Access Object for People table
///
/// Provides comprehensive CRUD operations and specialized queries for people/contact management.
/// This is the core DAO for pastoral care tracking, enabling pastors to manage their
/// congregation and identify who needs attention.
///
/// Key features:
/// - Basic CRUD (create, read, update, delete)
/// - Category filtering (elder, member, visitor, leadership, crisis, family, other)
/// - Search by name (full-text search ready)
/// - Pastoral care queries (overdue contacts, people needing attention)
/// - Household relationships
/// - Tag-based filtering
/// - Sync support (pending, synced, conflict states)
/// - Reactive streams for real-time UI updates
///
/// Usage example:
/// ```dart
/// final db = AppDatabase();
/// final peopleDao = PeopleDao(db);
///
/// // Get all people in a category
/// final elders = await peopleDao.getPeopleByCategory(userId, 'elder');
///
/// // Find people needing contact (overdue)
/// final overduePeople = await peopleDao.getPeopleNeedingContact(userId, settings);
///
/// // Search by name
/// final results = await peopleDao.searchPeople(userId, 'john');
///
/// // Create new person
/// final person = PeopleCompanion(
///   id: Value(Uuid().v4()),
///   userId: Value(userId),
///   name: const Value('John Smith'),
///   email: const Value('john@example.com'),
///   category: const Value('elder'),
/// );
/// await peopleDao.insertPerson(person);
/// ```
@DriftAccessor(tables: [People])
class PeopleDao extends DatabaseAccessor<AppDatabase> with _$PeopleDaoMixin {
  PeopleDao(AppDatabase db) : super(db);

  // ============================================================================
  // BASIC CRUD OPERATIONS
  // ============================================================================

  /// Get all people for a user (ordered by name)
  ///
  /// Returns people ordered alphabetically by name
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of all people
  Future<List<Person>> getAllPeople(String userId) {
    return (select(people)
          ..where((p) => p.userId.equals(userId))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get a single person by ID
  ///
  /// Returns null if person doesn't exist
  ///
  /// Parameters:
  /// - id: The person's UUID
  ///
  /// Returns: Person or null
  Future<Person?> getPersonById(String id) {
    return (select(people)..where((p) => p.id.equals(id))).getSingleOrNull();
  }

  /// Insert a new person
  ///
  /// Automatically sets sync metadata:
  /// - syncStatus = 'pending' (requires sync to server)
  /// - localUpdatedAt = current timestamp
  /// - version = 1 (initial version)
  ///
  /// Parameters:
  /// - person: PeopleCompanion with person data
  ///
  /// Returns: Row ID of inserted person
  Future<int> insertPerson(PeopleCompanion person) {
    return into(people).insert(person);
  }

  /// Update an existing person
  ///
  /// IMPORTANT: Caller must update sync metadata:
  /// ```dart
  /// final updatedPerson = person.copyWith(
  ///   name: 'New Name',
  ///   syncStatus: 'pending',
  ///   localUpdatedAt: DateTime.now().millisecondsSinceEpoch,
  ///   version: person.version + 1,
  /// );
  /// await peopleDao.updatePerson(updatedPerson);
  /// ```
  ///
  /// Parameters:
  /// - person: Complete Person object with updates
  ///
  /// Returns: true if update succeeded, false if person not found
  Future<bool> updatePerson(Person person) {
    return update(people).replace(person);
  }

  /// Delete a person (hard delete - permanently removes from database)
  ///
  /// WARNING: This is irreversible. When a person is deleted:
  /// - All contact logs for this person are also deleted (CASCADE)
  /// - All milestones for this person are deleted (CASCADE)
  /// - Tasks linked to this person have person_id set to NULL (SET NULL)
  /// - Events linked to this person have person_id set to NULL (SET NULL)
  ///
  /// Parameters:
  /// - id: The person's UUID
  ///
  /// Returns: Number of rows deleted (0 or 1)
  Future<int> deletePerson(String id) {
    return (delete(people)..where((p) => p.id.equals(id))).go();
  }

  // ============================================================================
  // CATEGORY-BASED QUERIES
  // ============================================================================

  /// Get all people in a specific category
  ///
  /// Categories:
  /// - 'elder': Church elders requiring regular check-ins
  /// - 'member': Regular church members
  /// - 'visitor': Visitors to the church
  /// - 'leadership': Leadership team members
  /// - 'crisis': People in crisis needing frequent contact
  /// - 'family': Pastor's family members
  /// - 'other': Other contacts
  ///
  /// Ordered by name alphabetically
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - category: Category value
  ///
  /// Returns: List of people in category
  Future<List<Person>> getPeopleByCategory(String userId, String category) {
    return (select(people)
          ..where((p) => p.userId.equals(userId) & p.category.equals(category))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Count people by category
  ///
  /// Useful for dashboard metrics
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Map of category to count
  ///
  /// Example: {'elder': 5, 'member': 45, 'visitor': 3, ...}
  Future<Map<String, int>> countPeopleByCategory(String userId) async {
    final allPeople = await (select(people)..where((p) => p.userId.equals(userId))).get();

    final counts = <String, int>{};
    for (final person in allPeople) {
      counts[person.category] = (counts[person.category] ?? 0) + 1;
    }

    return counts;
  }

  // ============================================================================
  // PASTORAL CARE - OVERDUE CONTACTS
  // ============================================================================

  /// Get people needing contact (overdue based on category frequency)
  ///
  /// This is a KEY query for pastoral care. It identifies people who haven't been
  /// contacted recently based on their category's contact frequency threshold.
  ///
  /// Logic:
  /// 1. For each person, determine their contact frequency:
  ///    - Use contact_frequency_override_days if set (person-specific)
  ///    - Otherwise use category default from user_settings
  /// 2. Calculate days since last contact
  /// 3. Return people where days_since_contact >= frequency_threshold
  ///
  /// This query is critical for the Smart Dashboard's pastoral care suggestions.
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - elderFrequency: Days between elder contacts (from user_settings)
  /// - memberFrequency: Days between member contacts (from user_settings)
  /// - crisisFrequency: Days between crisis contacts (from user_settings)
  /// - leadershipFrequency: Days between leadership contacts (default: 30)
  /// - visitorFrequency: Days between visitor follow-ups (default: 7)
  /// - familyFrequency: Days between family contacts (default: 7)
  /// - otherFrequency: Days between other contacts (default: 90)
  ///
  /// Returns: List of people needing contact, ordered by days overdue (most urgent first)
  Future<List<Person>> getPeopleNeedingContact(
    String userId, {
    required int elderFrequency,
    required int memberFrequency,
    required int crisisFrequency,
    int leadershipFrequency = 30,
    int visitorFrequency = 7,
    int familyFrequency = 7,
    int otherFrequency = 90,
  }) async {
    final now = DateTime.now();
    final allPeople = await (select(people)..where((p) => p.userId.equals(userId))).get();

    final needingContact = <Person>[];

    for (final person in allPeople) {
      // Skip people never contacted (they'll appear in "new contacts" list)
      if (person.lastContactDate == null) continue;

      // Determine frequency threshold for this person
      int frequencyDays;
      if (person.contactFrequencyOverrideDays != null) {
        frequencyDays = person.contactFrequencyOverrideDays!;
      } else {
        switch (person.category) {
          case 'elder':
            frequencyDays = elderFrequency;
            break;
          case 'member':
            frequencyDays = memberFrequency;
            break;
          case 'crisis':
            frequencyDays = crisisFrequency;
            break;
          case 'leadership':
            frequencyDays = leadershipFrequency;
            break;
          case 'visitor':
            frequencyDays = visitorFrequency;
            break;
          case 'family':
            frequencyDays = familyFrequency;
            break;
          case 'other':
            frequencyDays = otherFrequency;
            break;
          default:
            frequencyDays = memberFrequency;
        }
      }

      // Calculate days since last contact
      final daysSinceContact = now.difference(person.lastContactDate!).inDays;

      // Check if overdue
      if (daysSinceContact >= frequencyDays) {
        needingContact.add(person);
      }
    }

    // Sort by most overdue first (oldest last_contact_date)
    needingContact.sort((a, b) {
      if (a.lastContactDate == null && b.lastContactDate == null) return 0;
      if (a.lastContactDate == null) return 1;
      if (b.lastContactDate == null) return -1;
      return a.lastContactDate!.compareTo(b.lastContactDate!);
    });

    return needingContact;
  }

  /// Get people never contacted
  ///
  /// Returns people where last_contact_date IS NULL
  /// These are new contacts that need initial outreach
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of people never contacted
  Future<List<Person>> getPeopleNeverContacted(String userId) {
    return (select(people)
          ..where((p) => p.userId.equals(userId) & p.lastContactDate.isNull())
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.createdAt,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get people contacted in the last N days
  ///
  /// Useful for "recent contacts" views
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - days: Number of days to look back
  ///
  /// Returns: List of recently contacted people
  Future<List<Person>> getRecentlyContactedPeople(String userId, int days) {
    final cutoffDate = DateTime.now().subtract(Duration(days: days));

    return (select(people)
          ..where((p) =>
              p.userId.equals(userId) &
              p.lastContactDate.isNotNull() &
              p.lastContactDate.isBiggerOrEqualValue(cutoffDate))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.lastContactDate,
                  mode: OrderingMode.desc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // HOUSEHOLD QUERIES
  // ============================================================================

  /// Get all people in a specific household
  ///
  /// Useful for household-level pastoral care views
  ///
  /// Parameters:
  /// - householdId: UUID of the household
  ///
  /// Returns: List of people in that household
  Future<List<Person>> getPeopleByHousehold(String householdId) {
    return (select(people)
          ..where((p) => p.householdId.equals(householdId))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Get people not assigned to any household
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: List of people without households
  Future<List<Person>> getPeopleWithoutHousehold(String userId) {
    return (select(people)
          ..where((p) => p.userId.equals(userId) & p.householdId.isNull())
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // SEARCH AND FILTER
  // ============================================================================

  /// Search people by name (case-insensitive partial match)
  ///
  /// Uses LIKE query for flexible searching
  /// Example: "john" matches "John Smith", "Johnny Walker", "Mary Johnson"
  ///
  /// For full-text search on Supabase, use GIN index on to_tsvector(name)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Search term (will be wrapped in % for partial match)
  ///
  /// Returns: List of matching people
  Future<List<Person>> searchPeople(String userId, String query) {
    return (select(people)
          ..where((p) => p.userId.equals(userId) & p.name.contains(query))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Search people by email (case-insensitive partial match)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Email search term
  ///
  /// Returns: List of matching people
  Future<List<Person>> searchPeopleByEmail(String userId, String query) {
    return (select(people)
          ..where((p) =>
              p.userId.equals(userId) &
              p.email.isNotNull() &
              p.email.contains(query))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  /// Search people by phone (partial match)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - query: Phone search term (digits only recommended)
  ///
  /// Returns: List of matching people
  Future<List<Person>> searchPeopleByPhone(String userId, String query) {
    return (select(people)
          ..where((p) =>
              p.userId.equals(userId) &
              p.phone.isNotNull() &
              p.phone.contains(query))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .get();
  }

  // ============================================================================
  // SYNC SUPPORT
  // ============================================================================

  /// Get all people pending sync to server
  ///
  /// Returns people where sync_status = 'pending'
  /// Used by sync engine to identify what needs uploading
  ///
  /// Returns: List of people awaiting sync
  Future<List<Person>> getPendingPeople() {
    return (select(people)..where((p) => p.syncStatus.equals('pending'))).get();
  }

  /// Mark a person as successfully synced
  ///
  /// Updates:
  /// - syncStatus = 'synced'
  /// - serverUpdatedAt = server's updated_at timestamp
  ///
  /// Called after successful push to Supabase
  ///
  /// Parameters:
  /// - id: The person's UUID
  /// - serverUpdatedAt: Server's updated_at timestamp (Unix milliseconds)
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markPersonAsSynced(String id, int serverUpdatedAt) {
    return (update(people)..where((p) => p.id.equals(id))).write(
      PeopleCompanion(
        syncStatus: const Value('synced'),
        serverUpdatedAt: Value(serverUpdatedAt),
      ),
    );
  }

  /// Mark a person as conflicted (concurrent modifications)
  ///
  /// Parameters:
  /// - id: The person's UUID
  ///
  /// Returns: Number of rows updated (0 or 1)
  Future<int> markPersonAsConflicted(String id) {
    return (update(people)..where((p) => p.id.equals(id))).write(
      const PeopleCompanion(
        syncStatus: Value('conflict'),
      ),
    );
  }

  /// Get all people with sync conflicts
  ///
  /// Returns: List of conflicted people
  Future<List<Person>> getConflictedPeople() {
    return (select(people)..where((p) => p.syncStatus.equals('conflict'))).get();
  }

  // ============================================================================
  // REACTIVE STREAMS (for real-time UI updates)
  // ============================================================================

  /// Watch all people for a user (reactive stream)
  ///
  /// Returns a Stream that emits new list whenever people change
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Stream of people lists
  Stream<List<Person>> watchAllPeople(String userId) {
    return (select(people)
          ..where((p) => p.userId.equals(userId))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch people by category (reactive stream)
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - category: Category to filter by
  ///
  /// Returns: Stream of people lists
  Stream<List<Person>> watchPeopleByCategory(String userId, String category) {
    return (select(people)
          ..where((p) => p.userId.equals(userId) & p.category.equals(category))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch people in a household (reactive stream)
  ///
  /// Parameters:
  /// - householdId: UUID of the household
  ///
  /// Returns: Stream of people lists
  Stream<List<Person>> watchPeopleByHousehold(String householdId) {
    return (select(people)
          ..where((p) => p.householdId.equals(householdId))
          ..orderBy([
            (p) => OrderingTerm(
                  expression: p.name,
                  mode: OrderingMode.asc,
                ),
          ]))
        .watch();
  }

  /// Watch single person by ID (reactive stream)
  ///
  /// Parameters:
  /// - id: The person's UUID
  ///
  /// Returns: Stream of single person (or null if not found)
  Stream<Person?> watchPerson(String id) {
    return (select(people)..where((p) => p.id.equals(id))).watchSingleOrNull();
  }

  // ============================================================================
  // ANALYTICS AND STATISTICS
  // ============================================================================

  /// Count total people for a user
  ///
  /// Parameters:
  /// - userId: The user's UUID
  ///
  /// Returns: Total count of people
  Future<int> countPeople(String userId) async {
    final query = select(people)..where((p) => p.userId.equals(userId));
    final result = await query.get();
    return result.length;
  }

  /// Get contact statistics summary
  ///
  /// Returns counts for:
  /// - Total people
  /// - People never contacted
  /// - People overdue for contact
  /// - People contacted this week
  ///
  /// Parameters:
  /// - userId: The user's UUID
  /// - elderFrequency: Days between elder contacts
  /// - memberFrequency: Days between member contacts
  /// - crisisFrequency: Days between crisis contacts
  ///
  /// Returns: Map with statistic keys and counts
  Future<Map<String, int>> getContactStatistics(
    String userId, {
    required int elderFrequency,
    required int memberFrequency,
    required int crisisFrequency,
  }) async {
    final total = await countPeople(userId);
    final neverContacted = await getPeopleNeverContacted(userId);
    final overdue = await getPeopleNeedingContact(
      userId,
      elderFrequency: elderFrequency,
      memberFrequency: memberFrequency,
      crisisFrequency: crisisFrequency,
    );
    final recentlyContacted = await getRecentlyContactedPeople(userId, 7);

    return {
      'total': total,
      'never_contacted': neverContacted.length,
      'overdue': overdue.length,
      'contacted_this_week': recentlyContacted.length,
    };
  }
}
