# Drift Database Setup - Complete Summary

## Status: ✅ SUCCESSFULLY CONFIGURED

The local SQLite database for the Shepherd Flutter app has been successfully set up with Drift (offline-first architecture).

---

## Files Created

### 1. Core Database Files

| File | Purpose | Status |
|------|---------|--------|
| `lib/data/local/database.dart` | Main AppDatabase class with singleton pattern | ✅ Created |
| `lib/data/local/database.g.dart` | Auto-generated by build_runner | ✅ Generated |

### 2. Table Definitions

| File | Table | Records | Status |
|------|-------|---------|--------|
| `lib/data/local/tables/users_table.dart` | users | User profiles | ✅ Created |
| `lib/data/local/tables/user_settings_table.dart` | user_settings | User preferences | ✅ Created |
| `lib/data/local/tables/sync_queue_table.dart` | sync_queue | Offline sync queue | ✅ Created |

### 3. Documentation & Testing

| File | Purpose | Status |
|------|---------|--------|
| `lib/data/local/README.md` | Complete usage guide | ✅ Created |
| `lib/data/local/database_test_example.dart` | Example CRUD operations | ✅ Created |

---

## Database Schema

### Users Table
```dart
@DataClassName('User')
class Users extends Table {
  // Core fields
  TextColumn get id => text().clientDefault(() => const Uuid().v4())();
  TextColumn get email => text().unique()();
  TextColumn get name => text()();
  TextColumn get churchName => text().nullable()();
  TextColumn get timezone => text().withDefault(const Constant('America/Chicago'))();

  // Timestamps
  IntColumn get createdAt => integer().clientDefault(...)();
  IntColumn get updatedAt => integer().clientDefault(...)();

  // Sync metadata (REQUIRED for offline-first)
  TextColumn get syncStatus => text().withDefault(const Constant('synced'))();
  IntColumn get localUpdatedAt => integer().nullable()();
  IntColumn get serverUpdatedAt => integer().nullable()();
  IntColumn get version => integer().withDefault(const Constant(1))();
}
```

**Generated Data Class:** `User`
**Generated Companion Class:** `UsersCompanion`

---

### User Settings Table
```dart
@DataClassName('UserSetting')
class UserSettings extends Table {
  // Identity
  TextColumn get id => text().clientDefault(() => const Uuid().v4())();
  TextColumn get userId => text().references(Users, #id, onDelete: KeyAction.cascade)();

  // Contact frequency defaults (days)
  IntColumn get elderContactFrequencyDays => integer().withDefault(const Constant(30))();
  IntColumn get memberContactFrequencyDays => integer().withDefault(const Constant(90))();
  IntColumn get crisisContactFrequencyDays => integer().withDefault(const Constant(3))();

  // Sermon preparation
  IntColumn get weeklySermonPrepHours => integer().withDefault(const Constant(8))();

  // Daily scheduling
  IntColumn get maxDailyHours => integer().withDefault(const Constant(10))();
  IntColumn get minFocusBlockMinutes => integer().withDefault(const Constant(120))();
  TextColumn get preferredFocusHoursStart => text().nullable()();  // 'HH:MM'
  TextColumn get preferredFocusHoursEnd => text().nullable()();    // 'HH:MM'

  // Notifications (JSON)
  TextColumn get notificationPreferences => text().nullable()();

  // Offline & archiving
  IntColumn get offlineCacheDays => integer().withDefault(const Constant(90))();
  IntColumn get autoArchiveEnabled => integer().withDefault(const Constant(1))();
  IntColumn get archiveTasksAfterDays => integer().withDefault(const Constant(90))();
  IntColumn get archiveEventsAfterDays => integer().withDefault(const Constant(365))();
  IntColumn get archiveLogsAfterDays => integer().withDefault(const Constant(730))();

  // Timestamps & sync metadata (same as Users table)
  // ...
}
```

**Generated Data Class:** `UserSetting`
**Generated Companion Class:** `UserSettingsCompanion`
**Foreign Key:** `userId` → `users.id` (CASCADE on delete)
**Unique Constraint:** One settings record per user

---

### Sync Queue Table
```dart
@DataClassName('SyncQueueEntry')
class SyncQueue extends Table {
  IntColumn get id => integer().autoIncrement()();  // Primary key
  TextColumn get affectedTable => text()();         // 'users', 'tasks', etc.
  TextColumn get recordId => text()();              // UUID of affected record
  TextColumn get operation => text()();             // 'insert', 'update', 'delete'
  TextColumn get payload => text().nullable()();    // JSON data
  IntColumn get createdAt => integer().clientDefault(...)();
  IntColumn get retryCount => integer().withDefault(const Constant(0))();
  TextColumn get lastError => text().nullable()();
}
```

**Generated Data Class:** `SyncQueueEntry`
**Generated Companion Class:** `SyncQueueCompanion`
**Purpose:** Queue for background sync to Supabase

---

## Key Features

### ✅ Offline-First Architecture

All operations execute against local SQLite **first**, then sync to Supabase in background:

```dart
// User action happens
await db.updateUser(...);           // 1. Update local DB immediately
await db.addToSyncQueue(...);       // 2. Queue for background sync
// UI updates immediately (offline-first!)
```

### ✅ Sync Metadata

Every table includes four sync-related columns:

| Column | Type | Purpose |
|--------|------|---------|
| `sync_status` | TEXT | 'synced', 'pending', or 'conflict' |
| `local_updated_at` | INTEGER | Unix timestamp (ms) when locally modified |
| `server_updated_at` | INTEGER | Unix timestamp (ms) of last server state |
| `version` | INTEGER | Optimistic locking counter |

### ✅ Multi-Tenant Isolation

All data tables include `user_id` foreign key for row-level security:

```dart
TextColumn get userId => text().references(Users, #id)();
```

### ✅ Type Safety

Drift generates type-safe classes:

```dart
// ❌ BAD: Map<String, dynamic> (no type safety)
final user = {'email': 'test@example.com', 'name': 123};  // Oops! name is int

// ✅ GOOD: Generated User class (compile-time safety)
final user = User(
  id: '...',
  email: 'test@example.com',
  name: 'John Smith',  // Compiler enforces String type
);
```

### ✅ Foreign Key Constraints

```dart
// Cascade delete: When user deleted, settings auto-deleted
TextColumn get userId => text().references(Users, #id, onDelete: KeyAction.cascade)();
```

### ✅ UUID Primary Keys

All primary keys are UUIDs (client-generated, not auto-increment):

```dart
TextColumn get id => text().clientDefault(() => const Uuid().v4())();
```

**Why?** Enables offline record creation without server round-trip.

---

## Usage Guide

### Initialize Database

```dart
import 'package:shepherd/data/local/database.dart';

// Singleton pattern - same instance everywhere
final db = AppDatabase();
```

### Create Records

```dart
// Users
final userCompanion = UsersCompanion.insert(
  email: 'pastor@church.com',
  name: 'John Smith',
  churchName: const Value('First Baptist'),
);
await db.into(db.users).insert(userCompanion);

// User Settings
final settingsCompanion = UserSettingsCompanion.insert(
  userId: userId,
  elderContactFrequencyDays: const Value(30),
  notificationPreferences: Value(jsonEncode({'email': true})),
);
await db.into(db.userSettings).insert(settingsCompanion);
```

### Query Records

```dart
// Using convenience methods
final user = await db.getUserById(userId);
final settings = await db.getUserSettings(userId);

// Using Drift query API
final user = await (db.select(db.users)
  ..where((u) => u.email.equals('pastor@church.com'))
).getSingleOrNull();

// Get all pending records
final pendingUsers = await (db.select(db.users)
  ..where((u) => u.syncStatus.equals('pending'))
).get();
```

### Update Records

```dart
await (db.update(db.users)..where((u) => u.id.equals(userId))).write(
  UsersCompanion(
    name: const Value('Updated Name'),
    syncStatus: const Value('pending'),
    localUpdatedAt: Value(DateTime.now().millisecondsSinceEpoch),
  ),
);

// Or use convenience method
await db.markUserAsPending(userId);
```

### Delete Records

```dart
// Hard delete
await (db.delete(db.users)..where((u) => u.id.equals(userId))).go();

// Soft delete (recommended - add deleted_at column)
await (db.update(db.users)..where((u) => u.id.equals(userId))).write(
  UsersCompanion(
    deletedAt: Value(DateTime.now()),
    syncStatus: const Value('pending'),
  ),
);
```

### Transactions

```dart
await db.transaction(() async {
  await db.into(db.users).insert(userCompanion);
  await db.into(db.userSettings).insert(settingsCompanion);
  await db.into(db.syncQueue).insert(queueCompanion);
  // All succeed or all rollback
});
```

### Sync Queue Operations

```dart
// Add operation to queue
await db.into(db.syncQueue).insert(
  SyncQueueCompanion.insert(
    affectedTable: 'users',
    recordId: userId,
    operation: 'update',
    payload: Value(jsonEncode({'name': 'New Name'})),
  ),
);

// Get pending queue
final queue = await db.getPendingSyncQueue();

// Mark operation as failed
await db.updateSyncQueueFailure(queueEntryId, 'Network error');

// Remove successful operation
await db.removeSyncQueueEntry(queueEntryId);
```

---

## Build Runner Commands

### Generate Code (Required after schema changes)

```bash
cd c:\Users\Valdez\pastorapp\shepherd
flutter pub run build_runner build --delete-conflicting-outputs
```

**When to run:**
- After creating new table definitions
- After modifying existing tables
- After changing @DataClassName annotations
- When `database.g.dart` is missing or outdated

### Watch Mode (Auto-regenerate during development)

```bash
flutter pub run build_runner watch
```

Monitors file changes and regenerates automatically. Press `Ctrl+C` to stop.

### Clean Generated Files

```bash
flutter pub run build_runner clean
```

---

## Database Migrations

Current schema version: **1**

### Adding New Tables (Future)

1. Create table definition file in `lib/data/local/tables/`
2. Import in `database.dart`
3. Add to `@DriftDatabase(tables: [...])`
4. Increment `schemaVersion` to 2
5. Add migration logic:

```dart
@override
MigrationStrategy get migration {
  return MigrationStrategy(
    onCreate: (Migrator m) async {
      await m.createAll();
    },
    onUpgrade: (Migrator m, int from, int to) async {
      if (from == 1) {
        // Migration from v1 to v2
        await m.createTable(tasks);
        await m.createTable(calendarEvents);
      }
    },
  );
}
```

6. Run `build_runner build`

### Modifying Existing Tables

```dart
onUpgrade: (Migrator m, int from, int to) async {
  if (from == 1) {
    // Add column
    await m.addColumn(users, users.profileImageUrl);

    // Create index
    await customStatement('CREATE INDEX idx_users_email ON users(email)');
  }
}
```

---

## Testing

### Example Test File

Run the provided test example:

```dart
import 'package:shepherd/data/local/database_test_example.dart';

void main() async {
  await testDatabase();
}
```

This performs:
1. ✅ User creation
2. ✅ User query by email
3. ✅ User settings creation
4. ✅ User settings query
5. ✅ Record updates
6. ✅ Sync queue operations
7. ✅ Pending sync counts
8. ✅ Sync failure simulation
9. ✅ Foreign key constraint test
10. ✅ Transaction test

### Unit Testing with In-Memory Database

```dart
import 'package:drift/native.dart';
import 'package:test/test.dart';

void main() {
  late AppDatabase db;

  setUp(() {
    // Create fresh in-memory DB for each test
    db = AppDatabase.testConstructor(NativeDatabase.memory());
  });

  tearDown(() async {
    await db.close();
  });

  test('creating user works', () async {
    final user = UsersCompanion.insert(
      email: 'test@example.com',
      name: 'Test User',
    );

    await db.into(db.users).insert(user);

    final users = await db.select(db.users).get();
    expect(users.length, 1);
    expect(users.first.email, 'test@example.com');
  });
}
```

**Note:** Add test constructor to `AppDatabase`:

```dart
// In database.dart
AppDatabase.testConstructor(QueryExecutor e) : super(e);
```

---

## Database File Location

The SQLite file is stored at:

- **Android:** `/data/data/com.shepherd.app/app_flutter/shepherd.sqlite`
- **iOS:** `<App Documents>/shepherd.sqlite`
- **Desktop:** `<User Documents>/shepherd.sqlite`

View location in logs:
```
Database location: /data/data/com.shepherd.app/app_flutter/shepherd.sqlite
```

---

## Next Steps

### Immediate Tasks

1. ✅ ~~Set up Drift database~~ **COMPLETE**
2. ✅ ~~Create Users and UserSettings tables~~ **COMPLETE**
3. ✅ ~~Create SyncQueue table~~ **COMPLETE**
4. ⏳ **Add remaining tables** from technical specification:
   - `tasks` - Pastor's to-do items
   - `calendar_events` - Schedule management
   - `people` - Church members database
   - `contact_logs` - Member interaction history
   - `prayer_requests` - Prayer tracking
   - `sermon_prep` - Sermon preparation notes

### Future Enhancements

5. ⏳ **Implement sync engine** to process sync_queue
6. ⏳ **Add conflict resolution** logic (auto-merge strategy)
7. ⏳ **Create repository layer** abstracting database operations
8. ⏳ **Add indexes** for common query patterns
9. ⏳ **Implement full-text search** for people/sermons
10. ⏳ **Set up background sync** with WorkManager

---

## Verification Checklist

- [x] Drift dependencies installed (`drift`, `drift_dev`, `sqlite3_flutter_libs`)
- [x] Table definitions created with sync metadata
- [x] Foreign key constraints defined
- [x] `build_runner` executed successfully
- [x] `database.g.dart` generated without errors
- [x] UUID primary keys configured
- [x] Client-side defaults set (timestamps, sync_status)
- [x] Companion classes generated for inserts/updates
- [x] Singleton pattern implemented for AppDatabase
- [x] Migration strategy defined
- [x] Foreign key constraints enabled (`PRAGMA foreign_keys = ON`)
- [x] Documentation complete
- [x] Example test file provided

---

## Troubleshooting

### Build Runner Errors

**Error:** "Target of URI hasn't been generated"

```bash
# Solution: Run build_runner
flutter pub run build_runner build --delete-conflicting-outputs
```

**Error:** "Conflicting outputs"

```bash
# Solution: Use --delete-conflicting-outputs flag
flutter pub run build_runner build --delete-conflicting-outputs
```

### Database Errors

**Error:** "Foreign key constraint failed"

```dart
// Solution: Ensure referenced record exists
final user = await db.getUserById(userId);
if (user == null) {
  // Create user first
  await db.into(db.users).insert(userCompanion);
}
```

**Error:** "Database is locked"

```dart
// Solution: Close all connections before testing
await db.close();
```

### IDE Errors

**Error:** Red squiggles on `select()`, `update()`, etc.

**Solution:** These are expected before running `build_runner`. The errors disappear after code generation.

---

## Performance Targets

| Operation | Target | Notes |
|-----------|--------|-------|
| Simple query (by ID) | <50ms | Uses primary key index |
| Filter query (by user_id) | <100ms | Foreign key indexed |
| Complex join | <500ms | Multiple tables |
| Batch insert (100 records) | <1s | Use transactions |
| Sync queue processing | <2s | Background thread |

---

## References

- **Drift Documentation:** https://drift.simonbinder.eu/
- **Technical Specification:** `c:\Users\Valdez\pastorapp\shepherd_technical_specification.md`
- **Flutter Docs:** https://flutter.dev/
- **SQLite Documentation:** https://www.sqlite.org/

---

## Summary

The Shepherd app now has a **production-ready, offline-first SQLite database** powered by Drift. Key achievements:

✅ Three tables configured (users, user_settings, sync_queue)
✅ Type-safe generated code
✅ Sync metadata for offline-first architecture
✅ Foreign key constraints enforced
✅ UUID primary keys (client-generated)
✅ Comprehensive documentation
✅ Example test code provided

**The database is ready for integration with the sync engine and repository layer.**

---

**Created:** 2025-12-07
**Schema Version:** 1
**Build Tool:** build_runner 2.4.0
**Drift Version:** 2.14.0
